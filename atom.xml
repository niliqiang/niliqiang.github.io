<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>niliqiang&#39;s Blog</title>
  
  <subtitle>Welcome</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://niliqiang.github.io/"/>
  <updated>2020-03-23T15:04:32.326Z</updated>
  <id>https://niliqiang.github.io/</id>
  
  <author>
    <name>niliqiang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构--链表总结</title>
    <link href="https://niliqiang.github.io/2020/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://niliqiang.github.io/2020/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/</id>
    <published>2020-03-22T09:34:57.000Z</published>
    <updated>2020-03-23T15:04:32.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表的定义及优缺点："><a href="#链表的定义及优缺点：" class="headerlink" title="链表的定义及优缺点："></a>链表的定义及优缺点：</h3><blockquote><p>来自维基百科</p></blockquote><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>链表（Linked list）是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间。</p><p>链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个或下一个节点的位置的链接（”links”）。</p><a id="more"></a><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p><p>链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><h4 id="单链表的节点结构"><a href="#单链表的节点结构" class="headerlink" title="单链表的节点结构"></a>单链表的节点结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="单链表的设计实现"><a href="#单链表的设计实现" class="headerlink" title="单链表的设计实现"></a>单链表的设计实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyLinkedList() : list_size(<span class="number">0</span>), tail(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        dummy = <span class="keyword">new</span> ListNode(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= list_size) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ListNode* cur = dummy-&gt;next;  <span class="comment">//存储当前节点（从0开始）</span></span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* node = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        node-&gt;next = dummy-&gt;next;</span><br><span class="line">        dummy-&gt;next = node;</span><br><span class="line">        list_size++;  <span class="comment">//节点数自增</span></span><br><span class="line">        <span class="keyword">if</span> (tail == <span class="literal">nullptr</span>)  <span class="comment">//链表为空时先插入头节点</span></span><br><span class="line">            tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* node = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        <span class="keyword">if</span> (tail == <span class="literal">nullptr</span>) &#123;  <span class="comment">//tail指针为空，说明当前链表为空（list_size = 0）</span></span><br><span class="line">            tail = dummy;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = node;  <span class="comment">//添加新节点到链表末尾</span></span><br><span class="line">        tail = node;  <span class="comment">//tail指向最后一个节点</span></span><br><span class="line">        list_size++;  <span class="comment">//节点数自增</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; list_size || index &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)  <span class="comment">//在链表头部插入</span></span><br><span class="line">            addAtHead(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index == list_size)  <span class="comment">//在链表尾部插入</span></span><br><span class="line">            addAtTail(val);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ListNode* node = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">            ListNode* pre = dummy;  <span class="comment">//存储待插入节点的前一个节点</span></span><br><span class="line">            <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            node-&gt;next = pre-&gt;next;  <span class="comment">//待插入节点指向下一个节点</span></span><br><span class="line">            pre-&gt;next = node;  <span class="comment">//待插入节点的前一个节点指向待插入节点</span></span><br><span class="line">            list_size++;  <span class="comment">//链表长度自增</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= list_size || index &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        ListNode* pre = dummy;  <span class="comment">//存储待删除节点的前一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur = pre-&gt;next;  <span class="comment">//暂存待删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next == <span class="literal">nullptr</span>) tail = pre;  <span class="comment">//若待删除的为最后一个节点，尾指针前移</span></span><br><span class="line">        pre-&gt;next = cur-&gt;next;  <span class="comment">//待删除节点的前一个节点指向待删除节点的下一个节点，不用区分是否为最后一个节点</span></span><br><span class="line">        list_size--;  <span class="comment">//链表长度自减</span></span><br><span class="line">        <span class="keyword">delete</span> cur;  <span class="comment">//释放已删除的节点空间，注意，其他指向该节点的指针的内容也没了</span></span><br><span class="line">        cur = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> list_size;  <span class="comment">//记录链表长度</span></span><br><span class="line">    ListNode* dummy;  <span class="comment">//添加头节点，便于处理</span></span><br><span class="line">    ListNode* tail;  <span class="comment">//指向链表的头指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="链表题目总结"><a href="#链表题目总结" class="headerlink" title="链表题目总结"></a>链表题目总结</h3><h4 id="题目分类"><a href="#题目分类" class="headerlink" title="题目分类"></a>题目分类</h4><p><strong>长度的游戏</strong></p><p>多用快慢指针来实现，因为 2X-X = △k， 即X=△k，找到△k的意义，再在慢指针x上面接着做文章即可。举例 ： “链表中倒数第k个结点”，“两个链表的第一个公共结点”，“链表中环的入口结点”</p><p><strong>指针的游戏</strong></p><p>多加几个指针来解决问题（优先），也可以用vector等容器来装。举例： “反转链表”，“合并两个排序的链表”，“复杂链表的复制”，“删除链表中重复的节点”</p><h4 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h4><div class="table-container"><table><thead><tr><th>题目</th><th>考点</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">面试题22. 链表中倒数第k个节点</a></td><td>定义快慢节点指针，快的先走k步，然后两指针同步前进，待快指针到达尾后节点时，慢指针所指即为所得。</td></tr><tr><td><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46" target="_blank" rel="noopener">两个链表的第一个公共结点</a></td><td>长度的游戏：list1与list2的长度差很关键。先让长的走△步，然后一起遍历，第一个相同的就是要找的；时间复杂度 O(n+m)</td></tr><tr><td><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">链表中环的入口结点</a></td><td>快慢指针，两次相遇（第一次相遇之后，一个节点回到头节点，再次相遇点即为入口点）</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></td><td>可以用一个容器来装链表的每个节点，再反向构建链表，但这不是最佳思路；尝试多加链表的节点指针来解决。</td></tr><tr><td><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337" target="_blank" rel="noopener">合并两个排序的链表</a></td><td>非递归方法：使用三个指针，根据两个链表的当前节点大小依次追加；递归方法：根据当前节点大小递归追加。</td></tr><tr><td><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba" target="_blank" rel="noopener">复杂链表的赋值</a></td><td>先复制每一个结点，插入到原节点后边，拼成一个长链表，再拆分</td></tr><tr><td><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef" target="_blank" rel="noopener">删除链表中重复的节点</a></td><td>1. 首先添加一个头节点，以方便碰到第一个，第二个节点就相同的情况；2. 设置 pre ，last 指针， pre指针指向当前确定不重复的那个节点，而last指针相当于工作指针，一直往后面搜索。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">面试题06. 从尾到头打印链表</a></td><td>辅助栈，遍历入栈，出栈打印</td></tr></tbody></table></div><p><strong>参考链接：</strong></p><p><a href="https://mp.weixin.qq.com/s/hKjkITbCRcnZBafpjiwWJA" target="_blank" rel="noopener">基础数据结构：【动画】如何轻松手写链表？</a></p><p><a href="https://leetcode-cn.com/circle/article/YGr54o/" target="_blank" rel="noopener">力扣刷题总结之链表</a></p><p><a href="https://ztxpp.cc/2019/01/13/2-listNode/" target="_blank" rel="noopener">祝大哥的博客：牛客网 &gt; leetcode &gt; 链表算法 题目总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h2&gt;&lt;h3 id=&quot;链表的定义及优缺点：&quot;&gt;&lt;a href=&quot;#链表的定义及优缺点：&quot; class=&quot;headerlink&quot; title=&quot;链表的定义及优缺点：&quot;&gt;&lt;/a&gt;链表的定义及优缺点：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;来自维基百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h4&gt;&lt;p&gt;链表（Linked list）是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间。&lt;/p&gt;
&lt;p&gt;链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个或下一个节点的位置的链接（”links”）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://niliqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://niliqiang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="https://niliqiang.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法--常见算法例题总结</title>
    <link href="https://niliqiang.github.io/2020/02/15/%E7%AE%97%E6%B3%95-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://niliqiang.github.io/2020/02/15/%E7%AE%97%E6%B3%95-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2020-02-15T14:02:42.000Z</published>
    <updated>2020-03-23T14:43:27.266Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法相关的Leetcode题解</strong>见：<br><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md" target="_blank" rel="noopener">CS-Notes/notes/Leetcode 题解 - 目录.md</a></p><h2 id="1-贪心思想"><a href="#1-贪心思想" class="headerlink" title="1. 贪心思想"></a>1. 贪心思想</h2><p>在对问题求解时，总是做出在当前看来是最好的选择。<br>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。<br><strong>参考例题：</strong><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">452. 用最少数量的箭引爆气球</a></p><a id="more"></a><h2 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h2><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法，前提是数据结构必须先排好序，可以在数据规模的对数时间复杂度内（O(logn)）完成查找。但是，二分查找要求线性表具有有随机访问的特点（例如数组），也要求线性表能够根据中间元素的特点推测它两侧元素的性质，以达到缩减问题规模的效果。<br><strong>参考例题：</strong><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></p><h2 id="3-分治算法"><a href="#3-分治算法" class="headerlink" title="3. 分治算法"></a>3. 分治算法</h2><p>字面上的解释是「分而治之」，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。<br>分治算法通常以数学归纳法来验证。而它的计算成本则多数以解递归关系式来判定。<br><strong>参考例题：</strong><a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/" target="_blank" rel="noopener">241. 为运算表达式加括号</a></p><h2 id="4-搜索"><a href="#4-搜索" class="headerlink" title="4. 搜索"></a>4. 搜索</h2><h3 id="4-1-广度优先搜索BFS"><a href="#4-1-广度优先搜索BFS" class="headerlink" title="4.1 广度优先搜索BFS"></a>4.1 广度优先搜索BFS</h3><p>广度优先搜索一层一层地进行遍历，每层遍历都以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。需要注意的是，遍历过的节点不能再次被遍历。<br>应该注意的是，使用 BFS 只能求解<strong>无权图的最短路径</strong>，无权图是指从一个节点到另一个节点的代价都记为 1。（有权图可以用动态规划）<br>当每一次都可以判断出多种情况，有多次的时候就适合用BFS，在程序实现 BFS 时需要考虑以下问题：</p><ul><li>队列：用来存储每一轮遍历得到的节点；</li><li>标记：对于遍历过的节点，应该将它标记，防止重复遍历。</li></ul><p><strong>参考例题：</strong><a href="https://leetcode-cn.com/problems/perfect-squares" target="_blank" rel="noopener">279. 完全平方数(组成整数的最小平方数数量 )</a></p><h3 id="4-2-深度优先遍历DFS"><a href="#4-2-深度优先遍历DFS" class="headerlink" title="4.2 深度优先遍历DFS"></a>4.2 深度优先遍历DFS</h3><p>广度优先搜索一层一层遍历，每一层得到的所有新节点，要用队列存储起来以备下一层遍历的时候再遍历。而深度优先搜索在得到一个新节点时立即对新节点进行遍历。<br>从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种可达性问题。<br>在程序实现 DFS 时需要考虑以下问题：</p><ul><li>栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。</li><li>标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。</li></ul><p><strong>参考例题：</strong><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量(矩阵中的连通分量数目 )</a></p><h3 id="4-3-回溯Backtracking"><a href="#4-3-回溯Backtracking" class="headerlink" title="4.3 回溯Backtracking"></a>4.3 回溯Backtracking</h3><p>回溯属于DFS。</p><ul><li>普通 DFS 主要用在<strong>可达性</strong>问题 ，这种问题只需要执行到特点的位置然后返回即可。</li><li>而 Backtracking 主要用于求解<strong>排列组合</strong>问题，例如有 { ‘a’,’b’,’c’ } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。</li></ul><p>回溯算法事实上就是在一个树形问题上做深度优先遍历，因此首先需要把问题转换为树形问题。<br>因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：</p><ul><li>在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；</li><li>但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。</li></ul><p><strong>参考例题：</strong><br><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a><br><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a><br><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">77. 组合</a><br><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></p><h2 id="5-动态规划"><a href="#5-动态规划" class="headerlink" title="5. 动态规划"></a>5. 动态规划</h2><p>动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）等方式去解决。<br>一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的：</p><ul><li>每个阶段只有一个状态（斐波那契数列问题）-&gt;递推；</li><li>每个阶段的最优状态都是由上一个阶段的最优状态得到的（棋盘左上角到右下角问题）-&gt;贪心；</li><li>每个阶段的最优状态是由之前所有阶段的状态的组合得到的（迷宫里的最短路径问题）-&gt;搜索；</li><li>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。</li></ul><h3 id="5-1-动态规划题目特点："><a href="#5-1-动态规划题目特点：" class="headerlink" title="5.1 动态规划题目特点："></a>5.1 动态规划题目特点：</h3><ol><li>计数 -&gt; 有多少种方式走到右下角</li><li>求最值 -&gt; 最长上升子序列，零钱兑换（最少硬币个数）</li><li>求存在性 -&gt; 能不能选出k个数使得和为sum</li></ol><h3 id="5-2-动态规四个组成部分"><a href="#5-2-动态规四个组成部分" class="headerlink" title="5.2 动态规四个组成部分"></a>5.2 动态规四个组成部分</h3><h4 id="5-2-1-确定状态"><a href="#5-2-1-确定状态" class="headerlink" title="5.2.1 确定状态"></a>5.2.1 确定状态</h4><p>定义dp数组，注意最后一步和子问题。其中最后一步是指最优策略中的最后一个决策，子问题是规模更小的最优子策略</p><h4 id="5-2-2-转移方程"><a href="#5-2-2-转移方程" class="headerlink" title="5.2.2 转移方程"></a>5.2.2 转移方程</h4><p>根据子问题定义得到</p><h4 id="5-2-3-初始条件和边界情况"><a href="#5-2-3-初始条件和边界情况" class="headerlink" title="5.2.3 初始条件和边界情况"></a>5.2.3 初始条件和边界情况</h4><p>初始条件定义表示的是转移方程无法计算的初始值</p><h4 id="5-2-4-计算顺序"><a href="#5-2-4-计算顺序" class="headerlink" title="5.2.4 计算顺序"></a>5.2.4 计算顺序</h4><p>不论从小到大还是从大到小，一个原则是转移方程计算时，等号右边的值必须是已经计算过的。</p><p><strong>参考例题：</strong><br><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径的数量</a><br><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a><br><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集(0-1背包问题)</a><br><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></p><h2 id="6-数学相关"><a href="#6-数学相关" class="headerlink" title="6. 数学相关"></a>6. 数学相关</h2><h3 id="6-1-素数（质数）"><a href="#6-1-素数（质数）" class="headerlink" title="6.1 素数（质数）"></a>6.1 素数（质数）</h3><p>一个数只能被1或它本身整除就是质数，否则就是合数。<br><strong>参考例题：</strong><a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">204. 计数质数</a></p><h3 id="6-2-最大公约数，最小公倍数"><a href="#6-2-最大公约数，最小公倍数" class="headerlink" title="6.2 最大公约数，最小公倍数"></a>6.2 最大公约数，最小公倍数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最小公倍数为两数的乘积除以最大公约数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / gcd(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-进制转换"><a href="#6-3-进制转换" class="headerlink" title="6.3 进制转换"></a>6.3 进制转换</h3><p>注意处理负数和零的情况。<br><strong>参考例题：</strong><br><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/solution/c-zhan-fei-wei-yun-suan-by-sologala-2/" target="_blank" rel="noopener">405. 数字转换为十六进制数(栈)</a><br><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/solution/bu-guan-zheng-fu-tong-tong-zhuan-cheng-wu-fu-hao-z/" target="_blank" rel="noopener">405. 数字转换为十六进制数(转成无符号整型unsigned int处理)</a></p><h3 id="6-4-阶乘"><a href="#6-4-阶乘" class="headerlink" title="6.4 阶乘"></a>6.4 阶乘</h3><p><strong>参考例题：</strong><br><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noopener">172. 阶乘后的零</a><br>如果统计的是 N! 的二进制表示中最低位 1 的位置，也是同样的道理，只要统计有多少个 2 即可。</p><h3 id="6-5-字符串加减法"><a href="#6-5-字符串加减法" class="headerlink" title="6.5 字符串加减法"></a>6.5 字符串加减法</h3><p><strong>参考例题：</strong><br><a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener">67. 二进制字符串求和</a></p><h3 id="6-6-相遇问题，多数投票问题"><a href="#6-6-相遇问题，多数投票问题" class="headerlink" title="6.6 相遇问题，多数投票问题"></a>6.6 相遇问题，多数投票问题</h3><p>找中位数！<br><strong>参考例题：</strong><br><a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/" target="_blank" rel="noopener">462. 最少移动次数使数组元素相等 II</a></p><h3 id="6-7-其他"><a href="#6-7-其他" class="headerlink" title="6.7 其他"></a>6.7 其他</h3><h4 id="6-7-1-平方数"><a href="#6-7-1-平方数" class="headerlink" title="6.7.1 平方数"></a>6.7.1 平方数</h4><p>平方序列：1,4,9,16,..<br>间隔：3,5,7,…<br>间隔为等差数列，使用这个特性可以得到从 1 开始的平方序列。<br><strong>参考例题：</strong><a href="https://leetcode-cn.com/problems/valid-perfect-square/" target="_blank" rel="noopener">367. 有效的完全平方数</a></p><h4 id="6-7-2-乘积数组"><a href="#6-7-2-乘积数组" class="headerlink" title="6.7.2 乘积数组"></a>6.7.2 乘积数组</h4><p><strong>参考例题：</strong><a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">238. 除自身以外数组的乘积(乘积数组)</a></p><h4 id="6-7-3-二项式定理-快速幂"><a href="#6-7-3-二项式定理-快速幂" class="headerlink" title="6.7.3 二项式定理+快速幂"></a>6.7.3 二项式定理+快速幂</h4><p>阿里2.23笔试题第一道：N个人，任意选k个，再从k个里任选1个当队长，不同的队长算不同的组合,求总组合数。<br><strong>思路：</strong></p><blockquote><p>参考链接：<a href="https://www.nowcoder.com/discuss/389640" target="_blank" rel="noopener">阿里笔试讨论（3.23场)（附两道题AC的方法或代码）</a></p></blockquote><p>总数S = 0*C(N,0) + 1*C(N,1) + … + i*C(N,i) + N*C(N,N)<br>倒着加，由二项式定理：S + S = N*(C(N,0) + … + C(N,N)) = N*2^(N)<br>所以 S = N*2^(N-1)<br>接下来只需要考虑计算2^(N-1)的快速计算方法就好了（简单2分递归即可）<br>时间复杂度O(logN)。<br><strong>代码实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归快速求幂</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyPow</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">//m^n</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> m;</span><br><span class="line">    <span class="keyword">int</span> temp = MyPow(m, n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)(n%<span class="number">2</span>==<span class="number">0</span> ? <span class="number">1</span> : m) * temp * temp % <span class="number">1000000007</span>;  <span class="comment">//n为奇数时，需要额外乘m</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        res = (<span class="keyword">long</span> <span class="keyword">long</span>)n * MyPow(<span class="number">2</span>, n - <span class="number">1</span>) % <span class="number">1000000007</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// n比较小时可以这么算，n比较大时，递归过深会导致栈溢出，此时应使用二项式公式+快速幂的方式</span></span><br><span class="line"><span class="comment">// 由n个人里选k个人的组合数 = 由n-1个人里选k个人的组合数 + 由n-1个人里选k-1个人的组合数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Comm</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == k || k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Comm(n - <span class="number">1</span>, k) + Comm(n - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res += i * (Comm(n, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法相关的Leetcode题解&lt;/strong&gt;见：&lt;br&gt;&lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CS-Notes/notes/Leetcode 题解 - 目录.md&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-贪心思想&quot;&gt;&lt;a href=&quot;#1-贪心思想&quot; class=&quot;headerlink&quot; title=&quot;1. 贪心思想&quot;&gt;&lt;/a&gt;1. 贪心思想&lt;/h2&gt;&lt;p&gt;在对问题求解时，总是做出在当前看来是最好的选择。&lt;br&gt;贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。&lt;br&gt;&lt;strong&gt;参考例题：&lt;/strong&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;452. 用最少数量的箭引爆气球&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://niliqiang.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://niliqiang.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统--进程与线程</title>
    <link href="https://niliqiang.github.io/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>https://niliqiang.github.io/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-01-11T09:31:21.000Z</published>
    <updated>2020-03-21T15:35:28.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>一般来说<code>Linux</code>系统中的进程具备下列<strong>进程四要素</strong>：</p><p>（1）有一段程序供其执行，就好像一场戏有个剧本一样。不一定是进程所专有，可以与其他进程共用。</p><p>（2）有起码的”私有财产“，这就是进程专用的系统堆栈空间。</p><p>（3）有“户口”，这就是在内核中的一个<code>task_struct</code>数据结构，也称为“进程控制块（PCB）”，有了这个数据结构，进程才能成为内核调度的一个基本单位接受内核的调度。</p><p>（4）有独立的存储空间，意味着有专有的用户空间；也意味着除前述的系统空间堆栈外还有其专用的用户空间堆栈</p><a id="more"></a><p>如果只具备前面三条，那就称为“线程”。如果完全没有用户空间，就称为“内核线程”；如果共享用户空间就称为“用户线程”。“内核线程”和“用户线程”统称”线程“。</p><h3 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h3><p>在图2-1a中，一台多道（CPU在进程间快速的切换）程序计算机的内存中有四道程序。图2-1b中，这四道程序被抽象为4个各自拥有自己控制流程（即每个程序自己的逻辑程序计数器）的进程，并且每个程序都独立的运行。实际只有一个物理程序计数器，所以在每个程序运行时，它的逻辑程序计数器被装入实际的程序计数器中。当该程序执行结束（或暂定执行）时，物理程序计数器被保存在内存中该进程的逻辑程序计数器中。</p><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575008831336.png" alt="1575008831336"></p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>4种主要事件会导致进程的创建：</p><p>（1）系统初始化。</p><p>（2）正在运行的程序执行了创建进程的系统调用。</p><p>（3）用户请求创建一个新的进程。</p><p>（4）一个批处理作业的初始化。</p><p><strong>守护进程（daemon）</strong>：停留在后台，等待请求唤醒的进程。</p><p><strong>前台进程</strong>：同用户交互的进程。</p><p>在UNIX系统中，只有一个系统调用可以用来创建新进程：<code>fork</code>。这个系统调用会创建一个与调用进程相同的副本。在调用了fork后，父进程和子进程拥有相同的内存映像、同样的环境字符串和同样的打开文件。</p><p>在Windows中，一个Win32函数调用CreateProcess，既处理进程的创建，也负责把正确的程序装入新的进程。</p><p>在Unix和Windows中，进程创建之后，父进程和子进程有各自不同的地址空间。在Unix中，虽然子进程的初始地址是父进程的一个副本，但是这里涉及到两个不同的地址空间，<strong>不可写的内存区是共享的</strong>（写时复制共享）。在Windows中，从一开始父进程的地址空间和子进程的地址空间就是不同的。</p><h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>进程终止通常由下列条件引起：</p><ul><li>正常退出（自愿的）。</li><li>出错退出（自愿的）。</li><li>严重错误（非自愿）。</li><li>被其他进程杀死（非自愿）。</li></ul><h3 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h3><p>在Unix中，进程和它的所有子进程以及后裔共同组成一个进程组（树的概念），当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员（当前窗口创建的所有活动进程）。</p><p>在Windows中，没有进程层级的概念，所有的进程都是地位相同的。</p><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程的三种状态：</p><ul><li>运行态（该时刻进程实际占用CPU）。</li><li>就绪态（可运行，但因为其他进程正在运行而暂时停止）。</li><li>阻塞态（除非某种外部事件发生，否则进程不能运行）。</li></ul><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575017458130.png" alt="1575017458130"></p><h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p>为了实现进程模型，操作系统维护着一张表格（一个结构数组），即进程表。每个进程占用一个进程表项（进程控制块），该表项包含了进程状态的重要信息。</p><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575280520817.png" alt="1575280520817"></p><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575280572218.png" alt="1575280572218"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h3><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575862300843.png" alt="1575862300843"></p><h3 id="经典的线程模型"><a href="#经典的线程模型" class="headerlink" title="经典的线程模型"></a>经典的线程模型</h3><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575862438831.png" alt="1575862438831"></p><h3 id="POSIX线程"><a href="#POSIX线程" class="headerlink" title="POSIX线程"></a>POSIX线程</h3><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575873446381.png" alt="1575873446381"></p><h3 id="在用户空间和在内核中实现线程"><a href="#在用户空间和在内核中实现线程" class="headerlink" title="在用户空间和在内核中实现线程"></a>在用户空间和在内核中实现线程</h3><p>参考链接：<a href="https://blog.csdn.net/gatieme/article/details/51892437" target="_blank" rel="noopener">线程的3种实现方式—内核级线程, 用户级线程和混合型线程</a></p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><p>两个或多个进程读写某些共享数据，最后的结果取决于进程运行的精准时序，称为竞争条件。</p><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>互斥：阻止多个进程同时读写共享的数据。</p><p>临界区或临界区域：对共享内存进行访问的程序片段。</p><p>避免竞争条件的解决方案，需要满足以下四个条件：</p><p>（1）任何两个进程不能同时处于其临界区。<br>（2）不应该对CPU的速度和数量做任何假设。<br>（3）临界区外运行的进程不得阻塞其他进程。<br>（4）不得使进程无限期等待进入临界区。</p><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575877715463.png" alt="1575877715463"></p><h3 id="忙等待的互斥"><a href="#忙等待的互斥" class="headerlink" title="忙等待的互斥"></a>忙等待的互斥</h3><h4 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h4><p>进程在刚刚进入临界区后立即屏蔽所有中断，就要离开之前再打开中断。</p><p>弊端：把屏蔽中断的权力交给用户是不明智的；屏蔽中断只对当前CPU有效。、</p><h4 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h4><p>一个进程想进入临界区时，首先测试这把锁（读锁值），若锁值为0，将锁值设置为1并进入临界区；若这把锁的值已经是1了，则进程将等待直到其值变为0。</p><p>弊端：一个进程读锁值时为0，恰好在它将其值设置为1之前，另一个进程被调度执行，并将锁变量置为1，当第一个进程再次执行时，它也将该锁值置为1，此时两个进程进入临界区。</p><h4 id="严格轮换法"><a href="#严格轮换法" class="headerlink" title="严格轮换法"></a>严格轮换法</h4><p>忙等待：连续测试一个变量知道某个值出现为止。</p><p>自旋锁：用于忙等待的锁。</p><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575879557260.png" alt="1575879557260"></p><p>弊端：违反了上述条件（3）。</p><h4 id="Peterson解法"><a href="#Peterson解法" class="headerlink" title="Peterson解法"></a>Peterson解法</h4><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575880161618.png" alt="1575880161618"></p><p>弊端：需要忙等待。</p><h4 id="TSL指令"><a href="#TSL指令" class="headerlink" title="TSL指令"></a>TSL指令</h4><p>需要硬件支持，执行TSL的CPU将锁住内存总线，以禁止其他CPU在本指令结束之前访问内存。</p><p>弊端：需要忙等待。</p><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575880577971.png" alt="1575880577971"></p><h3 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h3><p>优先级反转问题：一台计算机有两个进程，H优先级较高，L优先级较低。调度规则规定，只要H处于就绪态它就可以运行。在某一时刻。L处于临界区中，此时H变道就绪态，准备运行。现在H开始忙等待，但由于当H就绪时L不会被调度，也就无法离开临界区，所以H将永远忙等待下去。</p><p>生产者-消费者问题（有界缓冲区问题）</p><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575881434973.png" alt="1575881434973"></p><p>由于未对count的访问加以限制，所以可能会出现竞争条件。当缓冲区为空，消费者刚刚读取count的值发现为0.此时调度程序决定暂停消费者并启动生产者。生产者想缓冲区加入一个数据项，count加一。现在count的值变为1了。它推断刚才由于count为0，所以消费者此时一定在睡眠，于是生产者调用wakeup来唤醒消费者。但是，消费者此时在逻辑上并未睡眠，所以wakeup信号丢失。当消费者下次运行时，它将测试先前读到的count值，发现它为0，于是睡眠。当生产者填满整个缓冲区后，也会睡眠。这样两个进程都会永远睡眠下去。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>down操作：检查信号量是否大于0，若该值大于0，则将其减1并继续；若该值为0，则进程将睡眠，而且此时down操作并未结束。</p><p>up操作：信号量的值增1和唤醒一个进程。</p><p>down操作和up操作均作为一个单一的，不可分割的原子操作完成。</p><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575944646051.png" alt="1575944646051"></p><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>当一个线程或进程需要访问临界区时，它调用mutex_lock。如果该互斥量当前是解锁的（临界区可用），则调用成功，调用线程可以自由进入临界区。若该互斥量已经加锁，调用线程被阻塞，直到临界区中的线程完成并调用mutex_unlock。如果多个线程被阻塞在该互斥量上，将随机选择一个线程并允许它获得锁。</p><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575948620788.png" alt="1575948620788"></p><p>只有一个缓冲区的生产者-消费者模型：</p><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575949378710.png" alt="1575949378710"></p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程是一个编程语言概念，一个管程是一个由过程、变量及数据结构等组成的一个集合，它们组成一个特殊的模块或者软件包。</p><p>管程一个很重要的特性：任一时刻管程中只能有一个活跃的进程，这一特性使管程能有效的完成互斥（引入条件变量以及wait和signal两个操作）。</p><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575959702672.png" alt="1575959702672"></p><h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575959877092.png" alt="1575959877092"></p><h3 id="避免锁：读-复制-更新"><a href="#避免锁：读-复制-更新" class="headerlink" title="避免锁：读-复制-更新"></a>避免锁：读-复制-更新</h3><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1575960667190.png" alt="1575960667190"></p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>1. 进程行为</strong></p><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1576047030233.png" alt="1576047030233"></p><ul><li>计算密集型：较长时间的CPU集中使用和较小频度的I/O等待</li><li>I/O密集型：较短时间的CPU集中使用和较高频度的I/O等待</li></ul><p><strong>2. 何时调度</strong></p><ul><li>非抢占式调度算法：挑选一个进程，然后让该进程运行直至被阻塞（阻塞在I/O上或者等待另一个进程），或者直到该进程自动释放CPU。</li><li>抢占式调度算法：挑选一个进程，并且让该进程运行某个固定时段的最大值。如果在该时段结束时，该进程仍在运行，它就被挂起，而调度程序挑选另一个进程运行（如果存在一个就绪进程）。</li></ul><p>抢占式调度算法需要在时间间隔末端发生时钟中断，如果没有可用的时钟，那么非抢占式调度算法就是唯一的选择。</p><p><strong>3. 调度算法分类</strong></p><p>不同的环境需要不同的调度算法。三种环境划分：</p><ul><li>批处理：非抢占式调度算法</li><li>交互式：抢占式</li><li>实时</li></ul><p><strong>4. 调度算法的目标</strong></p><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1576048518584.png" alt="1576048518584"></p><h3 id="批处理系统中的调度"><a href="#批处理系统中的调度" class="headerlink" title="批处理系统中的调度"></a>批处理系统中的调度</h3><p>（1）先来先服务<br>易于理解并且便于在程序中运用。<br>（2）最短作业优先<br>适用于运行时间可以预知的非抢占式批处理调度算法。<br>（3）最短剩余时间优先<br>最短作业优点的抢占式版本。</p><h3 id="交互式系统中的调度"><a href="#交互式系统中的调度" class="headerlink" title="交互式系统中的调度"></a>交互式系统中的调度</h3><p>（1）轮转调度</p><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1576135516186.png" alt="1576135516186"></p><p>进程切换（上下文切换）：需要1ms，包括切换内存映像、清除和重新调入高速缓存等。</p><p>时间片设置得太长（长于平均的CPU突发时间）可能引起对短的交互请求的响应时间变长，设置得太短又会导致过多的进程切换，降低CPU效率。将时间片设为20~50ms通常是一个比较合理的折中。</p><p>（2）优先级调度</p><p>为了防止高优先级进程无休止地运行下去，调度进程可能在每个时钟滴答（每个时钟中断）降低当前进程的优先级。另一个可能的做法是，给每个进程赋予一个允许运行的最大时间片，当用完这个时间片时，次高优先级的进程便会获得运行机会。</p><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1576461932403.png" alt="1576461932403">、</p><p>（3）多级队列</p><p>最高优先级类的进程运行一个时间片，次高优先级进程运行两个时间片，再次一级运行4个时间片，以此类推。当一个进程用完分配的时间片后，会被移到下一优先级类，即随着进程优先级不断降低，它的运行频度逐渐放慢。</p><p>（4）最短进程优先</p><p>根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。</p><p>（5）保证调度</p><p>向用户作出明确的性能保证。例如：若有用户同时有n个用户登录，则用户将获得CPU处理能力的1/n。</p><p>为了实现这个目标，系统需要跟踪各个进程自创建以来已使用了多少CPU时间，然后计算各个进程应获得的CPU时间。</p><p>（6）彩票调度</p><p>为进程提供各种系统资源（如CPU时间）的彩票，当需要作出调度决策时，就随机抽出一张彩票，拥有该彩票的进程获得资源。如果给三个进程分别分配10、25、50张彩票，那么它们会自动地按照大致2：4：5的比例划分CPU的使用。</p><p>（7）公平分享调度</p><p>以用户为基本单位分配CPU，不论这些用户本身有几个进程。</p><h3 id="实时系统中的调度"><a href="#实时系统中的调度" class="headerlink" title="实时系统中的调度"></a>实时系统中的调度</h3><p>实时系统通常可以分为硬实时和软实时，前者的含义是必须满足绝对的截止时间，后者的含义是虽然不需要偶尔错失截止时间，但是可以容忍。</p><p>实时系统中的事件可以按照响应方式进一步分类为周期性事件或非周期性事件。一个周期事件可以被调度的条件是处理该事件的CPU时间小于该事件的周期。</p><h3 id="策略和机制"><a href="#策略和机制" class="headerlink" title="策略和机制"></a>策略和机制</h3><p>将调度机制与调度策略分离，使得调度算法可以从用户进程接收有关的调度决策信息（调度算法参数化）。</p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p><img src="/2020/01/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1576467044640.png" alt="1576467044640"></p><p>用户级线程和内核级线程之间的差别在于性能，用户级线程的线程切换需要少量的机器指令，而内核级线程需要完整的上下文切换，修改内存映像，使高速缓存失效，这导致了若干数量级的延迟。另一方面，使用内核级线程时，一旦线程阻塞在I/O上就不需要像在用户级线程中那样将整个进程挂起。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;一般来说&lt;code&gt;Linux&lt;/code&gt;系统中的进程具备下列&lt;strong&gt;进程四要素&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;（1）有一段程序供其执行，就好像一场戏有个剧本一样。不一定是进程所专有，可以与其他进程共用。&lt;/p&gt;
&lt;p&gt;（2）有起码的”私有财产“，这就是进程专用的系统堆栈空间。&lt;/p&gt;
&lt;p&gt;（3）有“户口”，这就是在内核中的一个&lt;code&gt;task_struct&lt;/code&gt;数据结构，也称为“进程控制块（PCB）”，有了这个数据结构，进程才能成为内核调度的一个基本单位接受内核的调度。&lt;/p&gt;
&lt;p&gt;（4）有独立的存储空间，意味着有专有的用户空间；也意味着除前述的系统空间堆栈外还有其专用的用户空间堆栈&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://niliqiang.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://niliqiang.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程与线程" scheme="https://niliqiang.github.io/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--图</title>
    <link href="https://niliqiang.github.io/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    <id>https://niliqiang.github.io/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</id>
    <published>2020-01-10T09:47:42.000Z</published>
    <updated>2020-03-21T12:46:26.073Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。</p><p>注意：</p><ul><li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，在<strong>图中数据元素，我们则称之为顶点（Vertex）</strong>。</li><li>线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。在<strong>图结构中，不允许没有顶点</strong>。在定义中，若 V 是顶点的集合，则强调了顶点集合 V 有穷非空（关于点集是否为空有争议）。</li></ul><a id="more"></a><ul><li>线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而<strong>图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的</strong>。</li></ul><p><strong>无向图</strong>：图中任意两个顶点之间的边都是无向边（顶点之间的边没有方向，用无序偶对($v_i, v_j$)表示）。<br><strong>有向图</strong>：图中任意两个顶点之间的边都是有向边（从顶点$v_i$ 到 $v_j$的边有方向，用有序偶对\&lt;$v_i, v_j$&gt;来表示，也称为弧，$v_i$为弧尾，$v_j$为弧头）。<br><strong>简单图</strong>：图中不存在顶点到其自身的边，且一条边不重复出现的图。<br><strong>无向完全图</strong>：无向图中任意两个顶点之间都存在边的图。<br><strong>有向完全图</strong>：有向图中任意两个顶点之间都存在方向互为相反的两条弧的图。<br><strong>稀疏图</strong>：有很少条边或者弧的图，反之称为稠密图。<br><strong>网（Network）</strong>：带权（weight，与图的边或者弧相关的数）的图</p><p>对于无向图，<strong>顶点v的度</strong>是和该顶点相关联的边的数目，记为TD(v)；<br>无向图的边数是各顶点度数和的一半。<br>对于有向图，以顶点v为头的弧的数目称为<strong>v的入度</strong>，记为ID(v)；以v为尾的弧的数目称为<strong>v的出度</strong>，记为OD(v)；<br>有向图的弧条数等于各顶点的出度和等于各顶点的入度和。</p><p>路径的长度是路径上的边或弧的数目。<br>第一个顶点到最后一个顶点相同的路径称为<strong>回路或环（Cycle）</strong>。序列中顶点不重复出现的路径称为<strong>简单路径</strong>。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为<strong>简单回路或简单环</strong>。</p><p>在无向图 G 中，如果从顶点$v_i$到顶点$v_j$有路径，则称$v_i$和$v_j$是连通的。如果对于<br>图中任意两个顶点 $v_i, v_j∈E$，$v_i$和$v_j$都是连通的，则称 G 是<strong>连通图</strong>。<br>无向图中的极大连通子图称为<strong>连通分量</strong>。它强调：</p><ul><li>要是子图；</li><li>子图要是联通的；</li><li>连通子图含有极大顶点数；</li><li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</li></ul><p>在有向图 G 中，如果对于每一对的$v_i, v_j∈V$、$v_i ≠ v_j$，从$v_i$和$v_j$和从$v_j$和$v_i$都存在路径，则称 G 是强连通图。有向图中的极大强连通子图称做有向图的强连通分量。</p><p>一个<strong>连通图的生成树</strong>是一个极小的连通子图，它含有图中全部的 n 个顶点，但只有足以构成一棵树的 n-1 条边。<br>如果一个有向图恰有一个顶点的入度为0, 其余顶点的入度均为 1, 则是一棵<strong>有向树</strong>。<br>一个<strong>有向图的生成森林</strong>由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</p><h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。</p><p><img src="/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1577954859109.png" alt="无向图-邻接矩阵"></p><p><img src="/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1577954898647.png" alt="有向图-邻接矩阵"></p><p>缺点：对于边数相对顶点较少的图，对存储空间有较大浪费。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VEX100<span class="comment">// 最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AMGraph</span> &#123;</span></span><br><span class="line">VertexType vexs[MAX_VEX];<span class="comment">// 顶点表</span></span><br><span class="line">EdgeType arc[MAX_VEX][MAX_VEX];<span class="comment">// 邻接矩阵，可看做边表</span></span><br><span class="line"><span class="keyword">int</span> num_vertexes, num_edges;<span class="comment">// 图中当前的顶点数和边数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>对边或弧使用链式存储的方式来避免空间浪费的问题，这种数组与链表相结合的存储方法称为邻接表。<br>图中每个顶点$v_i$的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点$v_i$的边表，有向图则称为顶点$v_i$作为弧尾的出边表。</p><p><img src="/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1577955726420.png" alt="无向图-邻接表"></p><p>有向图的<strong>逆邻接表</strong>：对每个顶点$v_i$都建立一个链接为$v_i$为弧头的表.</p><p><img src="/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1577955927359.png" alt="无向图-邻接表"></p><p>对于带权值的网图，可以在边表结点定义中再增加一个 weight 的数据域，存储权值信息即可。</p><p><img src="/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1577956023701.png" alt="无向图-邻接表-带权"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> adjvex;</span><br><span class="line">EdgeType weight;</span><br><span class="line">EdgeNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> &#123;</span></span><br><span class="line">VertexType data;</span><br><span class="line">EdgeNode&lt;EdgeType&gt; *firstedge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该结构体是上两个结构体的整合</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALGraph</span> &#123;</span></span><br><span class="line">VertexNode&lt;VertexType, EdgeType&gt; adj_list[MAX_VEX];</span><br><span class="line"><span class="keyword">int</span> num_vertexes, num_edges;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><p>十字链表：把邻接表与逆邻接表结合起来的存储方法。</p><p><img src="/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1577957648958.png" alt="十字链表结点结构"></p><p><img src="/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1577957670974.png" alt="有向图-十字链表"></p><p>十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以$v_i$为尾的弧，也容易找到以$v_i$为头的弧，因而容易求得顶点的出度和入度。而且它除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的，因此，在有向图的应用中，十字链表是非常好的数据结构模型。</p><h4 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h4><p><img src="/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1577958480369.png" alt="邻接多重表结点结构"></p><p><img src="/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1577958506062.png" alt="无向图-邻接多重表"></p><h4 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h4><p>边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组毎个数据元素由一条边的起点下标（begin）终点下标（end）和权（weight）组成。</p><p>边集数组关注的是边的集合，在边集数组中要查找一个顶点的度需要扫描整个边数组，效率并不高。因此它更适合对边依次进行处理的操作，而不适合对顶点相关的操作。</p><p><img src="/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1577958720925.png" alt="有向图-边集数组-带权"></p><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历 (Traversing Graph)。</p><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p>深度优先遍历 (Depth_First_Search)，也称为深度优先搜索，简称为 DFS 。<br>深度优先遍历其实就是一个递归的过程，也是一棵树的前序遍历过程。<strong>它从图中某个顶点 v 出发，访问此顶点，然后从 v 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 v 有路径相通的顶点都被访问到。</strong>事实上，我们这里讲到的是连通图，对于非连通图，只需要对它的连通分量分别进行深度优先遍历，即在先前一个顶点进行一次深度优先遍历后，若图中尚有顶点未被访问，<strong>则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指示访问标志</span></span><br><span class="line"><span class="keyword">bool</span> visited_[MAX_VEX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵的深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(AMGraph&lt;VertexType, EdgeType&gt; *&amp;am_graph, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">visited_[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; am_graph-&gt;vexs[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; am_graph-&gt;num_vertexes; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (am_graph-&gt;arc[i][j] == <span class="number">1</span> &amp;&amp; !visited_[j]) &#123;  <span class="comment">//对未访问的邻接节点递归调用</span></span><br><span class="line">DFS(am_graph, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(AMGraph&lt;VertexType, EdgeType&gt; *&amp;am_graph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; am_graph-&gt;num_vertexes; i ++) &#123;</span><br><span class="line">visited_[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; am_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!visited_[i]) &#123;  <span class="comment">//对未访问过的节点调用DFS，若是连通图，则只会调用一次</span></span><br><span class="line">DFS(am_graph, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表的深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(ALGraph&lt;VertexType, EdgeType&gt; *&amp;al_graph, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">EdgeNode&lt;EdgeType&gt; *edge;</span><br><span class="line">visited_[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; al_graph-&gt;vexs[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">edge = al_graph-&gt;adj_list[i].firstedge;</span><br><span class="line"><span class="keyword">while</span> (edge) &#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[edge-&gt;adjvex]) &#123;  <span class="comment">//对未访问的邻接节点递归调用</span></span><br><span class="line">DFS(al_graph, edge-&gt;adjvex);</span><br><span class="line">&#125;</span><br><span class="line">edge = edge-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(ALGraph&lt;VertexType, EdgeType&gt; *&amp;al_graph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; al_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line">visited_[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; al_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!visited_[i]) &#123;  <span class="comment">//对未访问过的节点调用DFS，若是连通图，则只会调用一次</span></span><br><span class="line">DFS(al_graph, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比两个不同存储结构的深度优先遍历算法，对于 n 个顶点 e 条边的图来说，邻接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此都需要$O(n^2)$的时间。而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是$O(n+e)$显然对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。</p><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>广度优先遍历 (Breadth_First_Search)，又称为广度优先搜索，简称 BFS 。<br>如果说图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树的层序遍历。层序遍历之前需要将图稍微变形，变形原则是顶点 A 放置在最上第一层，让与它有边的顶点 B、F 为第二层，再让与 B 和 F 有边的顶点 C、I、G、E 为第三层，再将这四个顶点有边的 D、H 放在第四层。</p><p><img src="/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1578453974200.png" alt="BFS"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">邻接矩阵的广度遍历算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverseAM</span><span class="params">(AMGraph&lt;VertexType, EdgeType&gt; *&amp;am_graph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; vertex_queue;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; am_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line">visited[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; am_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">visited[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; am_graph-&gt;vexs[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">vertex_queue.push(i);  <span class="comment">//顶点index入队列</span></span><br><span class="line"><span class="keyword">while</span> (!vertex_queue.empty()) &#123;  <span class="comment">//若当前队列不为空</span></span><br><span class="line">i = vertex_queue.front();  <span class="comment">//返回当前队列首元素</span></span><br><span class="line">vertex_queue.pop();</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; am_graph-&gt;num_vertexes; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (am_graph-&gt;arc[i][j] == <span class="number">1</span> &amp;&amp; !visited[j]) &#123;</span><br><span class="line">visited[j] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; am_graph-&gt;vexs[j] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">vertex_queue.push(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">邻接表的广度遍历算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverseAL</span><span class="params">(ALGraph&lt;VertexType, EdgeType&gt; *&amp;al_graph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; vertex_queue;</span><br><span class="line">EdgeNode&lt;EdgeType&gt; *edge;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; al_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line">visited_[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; al_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!visited_[i]) &#123;</span><br><span class="line">visited_[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; al_graph-&gt;adj_list[i].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">vertex_queue.push(i);  <span class="comment">//顶点index入队列</span></span><br><span class="line"><span class="keyword">while</span> (!vertex_queue.empty()) &#123;  <span class="comment">//若当前队列不为空</span></span><br><span class="line">i = vertex_queue.front();  <span class="comment">//返回当前队列首元素</span></span><br><span class="line">vertex_queue.pop();</span><br><span class="line">edge = al_graph-&gt;adj_list[i].firstedge;</span><br><span class="line"><span class="keyword">while</span> (edge) &#123;</span><br><span class="line"><span class="keyword">if</span> (!visited_[edge-&gt;adjvex]) &#123;  <span class="comment">//若该节点未被访问</span></span><br><span class="line">visited_[edge-&gt;adjvex] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; al_graph-&gt;adj_list[edge-&gt;adjvex].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">vertex_queue.push(edge-&gt;adjvex);</span><br><span class="line">&#125;</span><br><span class="line">edge = edge-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图的深度优先遍历与广度优先遍历算法在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同。<strong>深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况。</strong></p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>我们把构造连通网的最小代价生成树称为最小生成树 (Minimum Cost Spanning Tree)。</p><h4 id="普里姆-Prim-算法"><a href="#普里姆-Prim-算法" class="headerlink" title="普里姆 (Prim) 算法"></a>普里姆 (Prim) 算法</h4><p>普里姆 (Prim) 算法是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树。<br>构造邻接矩阵：</p><p><img src="/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1578558836503.png" alt="Prim-邻接矩阵"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  最小生成树 Prim 算法的定义</span></span><br><span class="line"><span class="comment">  核心思想：遍历顶点，由顶点找最小权值对应的边</span></span><br><span class="line"><span class="comment">  图示例：9 15 012345678 0 1 10 0 5 11 1 2 18 1 6 16 1 8 12 2 3 22 2 8 8 3 4 20 3 6 24 3 7 16 3 8 21 4 5 26 4 7 7 5 6 17 6 7 19</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;VertexType, EdgeType&gt;::MiniSpanTreePrim(AMGraph&lt;VertexType, EdgeType&gt; *&amp;am_graph) &#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">min</span>, i, j, k;</span><br><span class="line"><span class="comment">//adjvex保存相关顶点下标；lowcost保存相关顶点间 边的权值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adjvex, lowcost;</span><br><span class="line">lowcost.push_back(<span class="number">0</span>);</span><br><span class="line">adjvex.push_back(<span class="number">0</span>);  <span class="comment">//初始化第一个顶点为v0</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; am_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line">lowcost.push_back(am_graph-&gt;arc[<span class="number">0</span>][i]);</span><br><span class="line">adjvex.push_back(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; am_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line"><span class="built_in">min</span> = MY_INFINITY;</span><br><span class="line">j = <span class="number">1</span>; k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; am_graph-&gt;num_vertexes) &#123;  <span class="comment">//遍历结点，查找最小权值 </span></span><br><span class="line"><span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j] &lt; <span class="built_in">min</span>) &#123;</span><br><span class="line"><span class="built_in">min</span> = lowcost[j];</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; adjvex[k] &lt;&lt; <span class="string">","</span> &lt;&lt; k &lt;&lt; <span class="string">") "</span>;</span><br><span class="line">lowcost[k] = <span class="number">0</span>;  <span class="comment">//当前顶点的权值置为0</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; am_graph-&gt;num_vertexes; j++) &#123;  <span class="comment">//“合并”顶点</span></span><br><span class="line"><span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; am_graph-&gt;arc[k][j] &lt; lowcost[j]) &#123;</span><br><span class="line">lowcost[j] = am_graph-&gt;arc[k][j];</span><br><span class="line">adjvex[j] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由算法代码中的循环嵌套可得知此算法的时间复杂度为$O(n^2)$。</p><h4 id="克鲁斯卡尔-Kruskal-算法"><a href="#克鲁斯卡尔-Kruskal-算法" class="headerlink" title="克鲁斯卡尔 (Kruskal) 算法"></a>克鲁斯卡尔 (Kruskal) 算法</h4><p>克鲁斯卡尔算法将各边按照权值大小排序，由小到大逐步连接顶点来构造最小生成树。<br>以下是 edge 边集数组结构的定义代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KruskalEdge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">begin</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line">EdgeType weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>将邻接矩阵转换成边集数组，并按照权值大小排序：</p><p><img src="/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1578620201925.png" alt="Kruskal-边集数组"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最小生成树 Kruskal 算法的定义</span></span><br><span class="line"><span class="comment">核心思想：边按照权值排序，由最小权值的边找对应顶点</span></span><br><span class="line"><span class="comment">图示例：9 15 012345678 0 1 10 0 5 11 1 2 18 1 6 16 1 8 12 2 3 22 2 8 8 3 4 20 3 6 24 3 7 16 3 8 21 4 5 26 4 7 7 5 6 17 6 7 19</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;VertexType, EdgeType&gt;::MiniSpanTreeKruskal(AMGraph&lt;VertexType, EdgeType&gt; *&amp;am_graph) &#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, j, n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;KruskalEdge&lt;EdgeType&gt;&gt; edges;  <span class="comment">//边集数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent(am_graph-&gt;num_vertexes, <span class="number">0</span>);</span><br><span class="line">KruskalEdge&lt;EdgeType&gt; kruskal_edge;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; am_graph-&gt;num_vertexes; i++) &#123;  <span class="comment">//边集数组初始化</span></span><br><span class="line"><span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; am_graph-&gt;num_vertexes; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (am_graph-&gt;arc[i][j] != MY_INFINITY) &#123;</span><br><span class="line">kruskal_edge.<span class="built_in">begin</span> = i;</span><br><span class="line">kruskal_edge.<span class="built_in">end</span> = j;</span><br><span class="line">kruskal_edge.weight = am_graph-&gt;arc[i][j];</span><br><span class="line">edges.push_back(kruskal_edge);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), CompareWeight);  <span class="comment">//边集数组按照权值由小到大排序</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; am_graph-&gt;num_edges; i++) &#123;</span><br><span class="line">n = FindIndex(parent, edges[i].<span class="built_in">begin</span>);</span><br><span class="line">m = FindIndex(parent, edges[i].<span class="built_in">end</span>);</span><br><span class="line"><span class="keyword">if</span> (n != m) &#123;  <span class="comment">//假如 n 与 m 不等，说明此边没有与现有生成树形成环路</span></span><br><span class="line">parent[n] = m;  <span class="comment">//将此边的结尾顶点放入下标为起点的 parent 中，表示此頂点已经在生成树集合中</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; edges[i].<span class="built_in">begin</span> &lt;&lt; <span class="string">","</span> &lt;&lt; edges[i].<span class="built_in">end</span> &lt;&lt; <span class="string">") "</span> &lt;&lt; edges[i].weight &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">权值按照由小到大的排序规则</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">CompareWeight</span><span class="params">(<span class="keyword">const</span> KruskalEdge&lt;EdgeType&gt; &amp;first, <span class="keyword">const</span> KruskalEdge&lt;EdgeType&gt; &amp;second)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> first.weight &lt; second.weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查找连线顶点的尾部下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindIndex</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;parent, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (parent[f] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">f = parent[f];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此算法的 FindIndex 函数由边数 edges 决定，时间复杂度为$O(logn)$，而外面有一个 for 循环 e 次。所以克鲁斯卡尔算法的时间复杂度为$O(nlogn)$。<br>对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以对于稀疏图有很大的优势；而普里姆算法对于稠密图，即边数非常多的情况会更好一些。</p><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第—个顶点是源点，最后一个顶点是终点。</p><h4 id="迪杰斯特拉-Dijkstra-算法"><a href="#迪杰斯特拉-Dijkstra-算法" class="headerlink" title="迪杰斯特拉 (Dijkstra) 算法"></a>迪杰斯特拉 (Dijkstra) 算法</h4><p>这是一个按路径长度递增的次序产生最短路径的算法。该算法一步步求出源点和终点之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到源点到终点的最短路径。<br>示例图如下所示：</p><p><img src="/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1578628039919.png" alt="Dijkstra"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path_matrix_, short_path_table_;  <span class="comment">//存储最短路径下标，到各点最短路径的权值和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最短路径 Dijkstra 算法的定义</span></span><br><span class="line"><span class="comment">核心思想：按路径长度递增的次序迭代（以前一次产生结果为基础）产生最短路径</span></span><br><span class="line"><span class="comment">图示例：9 16 012345678 0 1 1 0 2 5 1 2 3 1 3 7 1 4 5 2 4 1 2 5 7 3 4 2 3 6 3 4 5 3 4 6 6 4 7 9 5 7 5 6 7 2 6 8 7 7 8 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;VertexType, EdgeType&gt;::ShortestPathDijkstra(AMGraph&lt;VertexType, EdgeType&gt; *&amp;am_graph, <span class="keyword">int</span> v0, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path_matrix, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;short_path_table) &#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v, w, k, <span class="built_in">min</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; final_short_path(am_graph-&gt;num_vertexes, <span class="number">0</span>);  <span class="comment">//final_short_path[w]=1 表示求得顶点v0到vw的最短路径</span></span><br><span class="line"><span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; am_graph-&gt;num_vertexes; v++) &#123;  <span class="comment">//数据初始化</span></span><br><span class="line">path_matrix.push_back(<span class="number">0</span>);</span><br><span class="line">short_path_table.push_back(am_graph-&gt;arc[v0][v]);</span><br><span class="line">&#125;</span><br><span class="line">short_path_table[v0] = <span class="number">0</span>;  <span class="comment">//v0到本身的路径为0</span></span><br><span class="line">final_short_path[v0] = <span class="number">1</span>;  <span class="comment">//v0到本身不需要求路径</span></span><br><span class="line"><span class="keyword">for</span> (v = <span class="number">1</span>; v &lt; am_graph-&gt;num_vertexes; v++) &#123;</span><br><span class="line"><span class="built_in">min</span> = MY_INFINITY;</span><br><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; am_graph-&gt;num_vertexes; w++) &#123;  <span class="comment">//查找距离当前顶点最近的顶点k</span></span><br><span class="line"><span class="keyword">if</span> (final_short_path[w] == <span class="number">0</span> &amp;&amp; short_path_table[w] &lt; <span class="built_in">min</span>) &#123;  <span class="comment">//w顶点离v0顶点更近</span></span><br><span class="line">k = w;</span><br><span class="line"><span class="built_in">min</span> = short_path_table[w];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">final_short_path[k] = <span class="number">1</span>;  <span class="comment">//将目前找到的最近的顶点置为1</span></span><br><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; am_graph-&gt;num_vertexes; w++) &#123;</span><br><span class="line"><span class="keyword">if</span> (final_short_path[w] == <span class="number">0</span> &amp;&amp; (<span class="built_in">min</span> + am_graph-&gt;arc[k][w] &lt; short_path_table[w])) &#123;  <span class="comment">//经过k顶点的路径比现在这条路径短</span></span><br><span class="line">path_matrix[w] = k;</span><br><span class="line">short_path_table[w] = <span class="built_in">min</span> + am_graph-&gt;arc[k][w];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迪杰斯特拉 (Dijkstra) 算法解决了从某个源点到其余各顶点的最短路径问题。从循环嵌套可以很容易得到此算法的时间复杂度为$O(n^2)$。<br>如果我们还需要知道如 v3 到 v5，v1 到 v7 这样的任一顶点到其余所有顶点的最短路径怎么办呢？此时简单的办法就是对每个顶点当作源点运行一次迪杰斯特拉 (Dijkstra) 算法，等于在原有算法的基础上，再来一次循环，此时整个算法的时间复杂度就成了$O(n^3)$。</p><h4 id="弗洛伊德-Floyd-算法"><a href="#弗洛伊德-Floyd-算法" class="headerlink" title="弗洛伊德 (Floyd) 算法"></a>弗洛伊德 (Floyd) 算法</h4><p>示例如图所示：</p><p><img src="/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1578640691016.png" alt="Floyd"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; floyd_path_matrix_, floyd_short_path_;  <span class="comment">//存储最短路径的中转顶点下标，到各点最短路径的权值和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最短路径 Floyd 算法的定义</span></span><br><span class="line"><span class="comment">核心思想：迭代（以前一次寻找结果为基础）寻找顶点与顶点间的最短中转路径</span></span><br><span class="line"><span class="comment">图示例：9 16 012345678 0 1 1 0 2 5 1 2 3 1 3 7 1 4 5 2 4 1 2 5 7 3 4 2 3 6 3 4 5 3 4 6 6 4 7 9 5 7 5 6 7 2 6 8 7 7 8 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;VertexType, EdgeType&gt;::ShortestPathFloyd(AMGraph&lt;VertexType, EdgeType&gt; *&amp;am_graph, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;floyd_path_matrix, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;floyd_short_path) &#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v, w, k;</span><br><span class="line"><span class="comment">// 二维数组初始化</span></span><br><span class="line">floyd_path_matrix.resize(am_graph-&gt;num_vertexes);</span><br><span class="line">floyd_short_path.resize(am_graph-&gt;num_vertexes);</span><br><span class="line"><span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; am_graph-&gt;num_vertexes; v++) &#123;</span><br><span class="line">floyd_path_matrix[v].resize(am_graph-&gt;num_vertexes);</span><br><span class="line">floyd_short_path[v].resize(am_graph-&gt;num_vertexes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; am_graph-&gt;num_vertexes; v++) &#123;</span><br><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; am_graph-&gt;num_vertexes; w++) &#123;</span><br><span class="line">floyd_short_path[v][w] = am_graph-&gt;arc[v][w];</span><br><span class="line">floyd_path_matrix[v][w] = w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//k 代表的是中转顶点的下标。v 代表起始顶点，w代表结束顶点。</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; am_graph-&gt;num_vertexes; k++) &#123;</span><br><span class="line"><span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; am_graph-&gt;num_vertexes; v++) &#123;</span><br><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; am_graph-&gt;num_vertexes; w++) &#123;</span><br><span class="line"><span class="keyword">if</span> (floyd_short_path[v][w] &gt; floyd_short_path[k][v] + floyd_short_path[k][w]) &#123;  <span class="comment">//通过顶点k中转的路径小于当前路径</span></span><br><span class="line">floyd_short_path[v][w] = floyd_short_path[k][v] + floyd_short_path[k][w];</span><br><span class="line">floyd_path_matrix[v][w] = floyd_path_matrix[v][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>弗洛伊德 (Floyd) 算法，它的代码简洁到就是一个二重循环初始化加一个三重循环权值修正，就完成了所有顶点到所有顶点的最短路径计算。如此简单的实现，真是巧妙之极。很可惜由于它的三重循<br>环，因此也是$O(n^3)$时间复杂度。如果你面临需要求所有顶点至所有顶点的最短路径问题时，弗洛伊德算法应该是不错的选择。</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为 AOV 网 (Activity On Vertex Network)。<br>设 G=(V,E)是一个具有 n 个顶点的有向图，V 中的顶点序列 v1, v2, ⋯ , vn，满足若从顶点的到 vi 到 vj 有一条路径，则在顶点序列中顶点的必在顶点 vi 之前。则我们称这样的顶点序列为一个拓扑序列。拓扑排序，其实就是对一个有向图构造拓扑序列的过程。<br>对 AOV 网进行拓扑排序的基本思路是：从 AOV 网中选择一个入度为 0 的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者 AOV 网中不存在入度为 0 的顶点为止。考虑到算法过程中始终要查找入度为 0 的顶点，我们在原来顶点表结点结构中，增加一个入度域 in，结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> in;<span class="comment">//顶点入度</span></span><br><span class="line">VertexType data;<span class="comment">//顶点域，存储顶点信息</span></span><br><span class="line">EdgeNode&lt;EdgeType&gt; *firstedge;<span class="comment">//边表头栺针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示例有向图如下：</p><p><img src="/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1578649533784.png" alt="拓扑排序-有向图"></p><p><img src="/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1578649563477.png" alt="拓扑排序-邻接表"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">拓扑排序的定义</span></span><br><span class="line"><span class="comment">函数功能：若网图无回路，输出拓扑排序序列并返回true，若有回路则返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="keyword">bool</span> Graph&lt;VertexType, EdgeType&gt;::TopologicalSort(ALGraph&lt;VertexType, EdgeType&gt; *&amp;al_graph) &#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, k, get_top;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">//用于栈指针下标；统计输出顶点的个数</span></span><br><span class="line">EdgeNode&lt;EdgeType&gt; *edge;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; vertex_stack;  <span class="comment">//存储处理过程中入度为 0 的顶点，目的是为了避免每个查找时都要去遍历顶点表找有没有入度为0的顶点。</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; al_graph-&gt;num_vertexes; i++) &#123;  <span class="comment">//初始化填充入度数字段</span></span><br><span class="line"><span class="keyword">for</span> (edge = al_graph-&gt;adj_list[i].firstedge; edge; edge = edge-&gt;next) &#123;  <span class="comment">//遍历该顶点对应的边表</span></span><br><span class="line">al_graph-&gt;adj_list[edge-&gt;adjvex].in++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; al_graph-&gt;num_vertexes; i++) &#123;  <span class="comment">//当前入度为零的顶点入栈</span></span><br><span class="line"><span class="keyword">if</span> (al_graph-&gt;adj_list[i].in == <span class="number">0</span>) &#123;</span><br><span class="line">vertex_stack.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!vertex_stack.empty()) &#123;</span><br><span class="line">get_top = vertex_stack.top();</span><br><span class="line">vertex_stack.pop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; al_graph-&gt;adj_list[get_top].data &lt;&lt; <span class="string">" -&gt; "</span>;</span><br><span class="line">++count;</span><br><span class="line"><span class="keyword">for</span> (edge = al_graph-&gt;adj_list[get_top].firstedge; edge; edge = edge-&gt;next) &#123;  <span class="comment">//遍历该顶点对应的边表</span></span><br><span class="line">k = edge-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span> (!(--al_graph-&gt;adj_list[k].in)) &#123;  <span class="comment">//当前入度为零的顶点入栈</span></span><br><span class="line">vertex_stack.push(k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count &lt; al_graph-&gt;num_vertexes) &#123;  <span class="comment">//count小于顶点个数，存在环</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对一个具有 n 个顶点 edge 条弧的 AOV 网来说，扫描顶点表，将入度为 0 的顶点入栈的时间复杂为 $O(n)$，而之后的 while 循环中，每个顶点进一次栈，出一次栈，入度减 1 的操作共执行了 edge 次，所以整个算法的时间复杂度为$O(n+edge)$。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;图的定义&quot;&gt;&lt;a href=&quot;#图的定义&quot; class=&quot;headerlink&quot; title=&quot;图的定义&quot;&gt;&lt;/a&gt;图的定义&lt;/h3&gt;&lt;p&gt;图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性表中我们把数据元素叫元素，树中将数据元素叫结点，在&lt;strong&gt;图中数据元素，我们则称之为顶点（Vertex）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。在&lt;strong&gt;图结构中，不允许没有顶点&lt;/strong&gt;。在定义中，若 V 是顶点的集合，则强调了顶点集合 V 有穷非空（关于点集是否为空有争议）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://niliqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://niliqiang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://niliqiang.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--二叉树</title>
    <link href="https://niliqiang.github.io/2020/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://niliqiang.github.io/2020/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-01-02T03:31:04.000Z</published>
    <updated>2020-03-21T12:44:12.610Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p>二叉树（Binary Tree）是 n（n &gt;= 0）个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左二叉树和右二叉树组成。</p><p><strong>注：</strong>二叉树不是树的特例，因为二叉树的孩子有左右之分，树是图的特例，二叉树可以为空，图（包括树）不能为空。（不同参考书籍的描述不一，有待考量）</p><a id="more"></a><h4 id="二叉树特点"><a href="#二叉树特点" class="headerlink" title="二叉树特点"></a>二叉树特点</h4><ul><li>每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。</li><li>左子树和右子树是有顺序的，次序不能任意颠倒。</li><li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。</li></ul><p><strong>二叉树的五种基本形态：</strong></p><ol><li>空二叉树：结点个数为零的二叉树（普通树的结点个数至少为1）</li><li>只有一个根结点</li><li>根结点只有左子树</li><li>根结点只有右子树</li><li>根结点既有左子树又有右子树</li></ol><h4 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h4><ol><li>斜树</li></ol><p>所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p><ol><li>满二叉树</li></ol><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p><p><strong>满二叉树的特点：</strong></p><p>（1）叶子只能出现在最下一层。<br>（2）非叶子结点的度一定是2。<br>（3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</p><ol><li>完全二叉树</li></ol><p>对一棵具有 n 个结点的二叉树<strong>按层序编号</strong>，如果编号为 i (1&lt;=i&lt;=n) 的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p><p><strong>完全二叉树的特点：</strong></p><p>（1）叶子结点只能出现在最下两层。<br>（2）最下层的叶子一定集中在左部连续位置。<br>（3）倒数二层，若有叶子结点，一定都在右部连续位置。<br>（4）如果结点度为1, 则该结点只有左孩子，即不存在只有右子树的情况。<br>（5）同样结点数的二叉树，完全二叉树的深度最小。</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ol><li>在二叉树的第i层上至多有$2^{i-1}$个结点(i&gt;=1)</li><li>深度为k的二叉树至多有$2^k-1$个结点</li><li>对任何一棵二叉树T，如果其终端结点数为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则$n_0=n_2+1$。</li><li>具有 n 个结点的完全二叉树的深度为$log_2n$向下取整然后+1。</li><li>如果对一棵有n个结点的完全二叉树的结点按层序编号，对任一结点i(1&lt;=i&lt;=n)有：</li></ol><ul><li>如果 i=1，则结点 i 是二叉树的根，无双亲；如果 i&gt;1，则其双亲是结点 i/2 向下取整。</li><li>如果 2i&gt;n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点 2i。</li><li>如果 2i+1&gt;n，则结点 i 无右孩子；否则其右孩子是结点 2i+1。</li></ul><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h4><p><img src="/2020/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/1577178946436.png" alt="二叉树的顺序存储结构"></p><p>顺序存储结构一般只用于完全二叉树。</p><h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p>二叉链表：一个数据域和两个指针域</p><p>| lchild | data | rchild |</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span><span class="comment">// 结点结构</span></span><br><span class="line">T data;</span><br><span class="line">BiTNode&lt;T&gt; *lchild, *rchild;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参构造函数</span></span><br><span class="line">BiTNode() :lchild(<span class="literal">NULL</span>), rchild(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带默认值的有参构造函数</span></span><br><span class="line">BiTNode(T mData, BiTNode&lt;T&gt; *l = <span class="literal">NULL</span>, BiTNode&lt;T&gt; *r = <span class="literal">NULL</span>) :data(mData), lchild(l), rchild(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构示意图如图所示：</p><p><img src="/2020/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/1577180067572.png" alt="二叉链表"></p><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>二叉树的遍历（traversing binary tree）是指从根结点出发，<strong>按照某种次序依次访问</strong>二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p><p><strong>1. 前序遍历</strong></p><p>若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</p><p><img src="/2020/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/1577180397220.png" alt="前序"></p><p><strong>2. 中序遍历</strong></p><p>若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。</p><p><img src="/2020/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/1577180782951.png" alt="中序"></p><p><strong>3. 后序遍历</strong></p><p>若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。</p><p><img src="/2020/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/1577180889635.png" alt="后序"></p><p><strong>4. 层序遍历</strong></p><p>若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p><p><img src="/2020/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/1577180957043.png" alt="层序"></p><h4 id="前序遍历算法"><a href="#前序遍历算法" class="headerlink" title="前序遍历算法"></a>前序遍历算法</h4><ol><li>采用前序遍历的递归算法：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTNode&lt;T&gt; *&amp;subTree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; subTree-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        PreOrderTraverse(subTree-&gt;lchild);</span><br><span class="line">        PreOrderTraverse(subTree-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>前序遍历的非递归算法：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverser_NoRecursion</span><span class="params">(BiTNode&lt;T&gt; *&amp;root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BiTNode&lt;T&gt; *&gt; s;</span><br><span class="line">    BiTNode&lt;T&gt; *t;</span><br><span class="line">    s.push(root);<span class="comment">//根结点进栈</span></span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        t = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;rchild != <span class="literal">NULL</span>)<span class="comment">//后进栈的先弹出（LIFO）</span></span><br><span class="line">        &#123;</span><br><span class="line">        s.push(t-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        s.push(t-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历算法"><a href="#中序遍历算法" class="headerlink" title="中序遍历算法"></a>中序遍历算法</h4><p>中序遍历的递归算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTNode&lt;T&gt; *&amp;subTree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">InOrderTraverse(subTree-&gt;lchild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; subTree-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">InOrderTraverse(subTree-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历算法"><a href="#后序遍历算法" class="headerlink" title="后序遍历算法"></a>后序遍历算法</h4><p>后序遍历的递归算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTNode&lt;T&gt; *&amp;subTree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">PostOrderTraverse(subTree-&gt;lchild);</span><br><span class="line">PostOrderTraverse(subTree-&gt;rchild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; subTree-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层级遍历算法"><a href="#层级遍历算法" class="headerlink" title="层级遍历算法"></a>层级遍历算法</h4><p>层级遍历的非递归算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraverse_NoRecursion</span><span class="params">(BiTNode&lt;T&gt; *&amp;root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;BiTNode&lt;T&gt; *&gt; q;</span><br><span class="line">BiTNode&lt;T&gt; *t;</span><br><span class="line">q.push(root);</span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">t = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;lchild != <span class="literal">NULL</span>)<span class="comment">//先进队列的先弹出（FIFO）</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(t-&gt;lchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(t-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>指向前驱结点和后继结点的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树。<br>对二叉树以某种次序<strong>遍历</strong>使其变为线索二叉树的过程称做是<strong>线索化</strong>。<br>线索化的过程就是在遍历的过程中<strong>修改空指针</strong>的过程。</p><p>线索二叉树的结点结构：<br>| lchild | ltag | data | rtag | rchild |</p><p>其中：</p><ul><li>ltag 为 0 时指向该结点的左孩子，为 1 时指向该结点的前驱。</li><li>rtag 为 0 时指向该结点的右孩子，为 1 时指向该结点的后继。</li></ul><p>如果所用的二叉树需经常遍历或査找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p><h3 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h3><h4 id="树转换成二叉树"><a href="#树转换成二叉树" class="headerlink" title="树转换成二叉树"></a>树转换成二叉树</h4><p>转换步骤如下：</p><ol><li>加线。在所有兄弟结点之间加一条连线。</li><li>去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。（叶子节点没有孩子结点，不用去线）</li><li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</li></ol><p><img src="/2020/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/1577928904792.png" alt="树转换成二叉树"></p><h4 id="森林转换成二叉树"><a href="#森林转换成二叉树" class="headerlink" title="森林转换成二叉树"></a>森林转换成二叉树</h4><p>森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。</p><ol><li>把每一棵树转换成二叉树</li><li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。</li></ol><p><img src="/2020/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/1577929041820.png" alt="森林转换成二叉树"></p><h4 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h4><p>树的遍历分为两种方式：</p><ol><li>先根遍历树：先访问树的根节点，然后依次先根遍历每棵子树（前序遍历）</li><li>后根遍历树：先依次后根遍历每棵子树，然后再访问根节点（中序遍历）</li></ol><p>森林的遍历也分为两种方式：</p><ol><li>前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。</li><li>后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。</li></ol><h3 id="赫夫曼树及应用"><a href="#赫夫曼树及应用" class="headerlink" title="赫夫曼树及应用"></a>赫夫曼树及应用</h3><h4 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h4><p>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做<strong>路径长度</strong>。<strong>树的路径长度</strong>就是从树根到每一结点的路径长度之和。<br>如果考虑到带权的结点，<strong>结点的带权的路径长度</strong>为从该结点到树根之间的路径长度与结点上权的乘积。<strong>树的带权路径长度</strong>为树中所有叶子结点的带权路径长度之和。<br>带权路径长度最小的二叉树称做<strong>赫夫曼树</strong>。</p><p>构造赫夫曼树的赫夫曼算法描述：</p><ol><li>根据给定的 n 个权值$\{w_1, w_2, … ,w_n\}$构成 n 棵二叉树的集合$F=\{T_1, T_2, … ,T_n\}$，其中每棵二叉树$T_i$中只有一个带权为$w_i$根结点，其左右子树均为空。</li><li>在 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li><li>在 F 中删除这两棵树，同时将新得到的二叉树加入 F 中。</li><li>重复 2 和 3 步骤，直到 F 只含一棵树为止。这棵树便是赫夫曼树。</li></ol><h4 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h4><p>一般地，设需要编码的字符集为$\{d_1, d_2, … ,d_n\}$，各个字符在电文中出现的次数或频率集合为$\{w_1, w_2, … ,w_n\}$，以${d_1, d_2, … ,d_n}$为叶子结点，${w_1, w_2, … ,w_n}$作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表 0，右分支代表 1，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;二叉树的定义&quot;&gt;&lt;a href=&quot;#二叉树的定义&quot; class=&quot;headerlink&quot; title=&quot;二叉树的定义&quot;&gt;&lt;/a&gt;二叉树的定义&lt;/h3&gt;&lt;p&gt;二叉树（Binary Tree）是 n（n &amp;gt;= 0）个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左二叉树和右二叉树组成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;二叉树不是树的特例，因为二叉树的孩子有左右之分，树是图的特例，二叉树可以为空，图（包括树）不能为空。（不同参考书籍的描述不一，有待考量）&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://niliqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://niliqiang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://niliqiang.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>C++11 中的 Defaulted 和 Deleted 函数</title>
    <link href="https://niliqiang.github.io/2019/11/25/C-11-%E4%B8%AD%E7%9A%84-Defaulted-%E5%92%8C-Deleted-%E5%87%BD%E6%95%B0/"/>
    <id>https://niliqiang.github.io/2019/11/25/C-11-%E4%B8%AD%E7%9A%84-Defaulted-%E5%92%8C-Deleted-%E5%87%BD%E6%95%B0/</id>
    <published>2019-11-25T11:53:29.000Z</published>
    <updated>2020-03-23T14:45:56.630Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.ibm.com/developerworks/cn/aix/library/1212_lufang_c11new/index.html" target="_blank" rel="noopener">C++11 标准新特性：Defaulted 和 Deleted 函数</a></p></blockquote><h3 id="1、Defaulted函数"><a href="#1、Defaulted函数" class="headerlink" title="1、Defaulted函数"></a>1、Defaulted函数</h3><p>C++ 的类有四类特殊成员函数，它们分别是：默认构造函数、析构函数、拷贝构造函数以及拷贝赋值运算符。这些类的特殊成员函数负责创建、初始化、销毁，或者拷贝类的对象。</p><p>如果程序员没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，则编译器会隐式的为这个类生成一个默认的特殊成员函数。 如：</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="keyword">int</span> a; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">X x;</span><br></pre></td></tr></table></figure><p>但是，如果程序员为类 X 显式的自定义了非默认构造函数（带参数），却没有定义默认构造函数的时候，编译器将不再会为它隐式的生成默认构造函数。如果需要用到默认构造函数来创建类的对象时，程序员必须自己显式的定义默认构造函数。 如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">X()&#123;&#125;;  <span class="comment">// 手动定义默认构造函数</span></span><br><span class="line">X(<span class="keyword">int</span> i)&#123; </span><br><span class="line">a = i; </span><br><span class="line">&#125;     </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="keyword">int</span> a; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X x;<span class="comment">// 正确，默认构造函数 X::X() 存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中的矛盾之处：</p><ul><li>原本期望编译器自动生成的默认构造函数需要程序员手动编写，程序员的工作量加大。</li><li>手动编写的默认构造函数的代码执行效率比编译器自动生成的默认构造函数低。</li></ul><p>为了解决上述矛盾，C++ 11 中提出了 Defaulted 函数。程序员只需在函数声明后加上 “=default;”，就可将该函数声明为 defaulted 函数，<strong>编译器将为显式声明的 defaulted 函数自动生成函数体</strong>。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">X()= <span class="keyword">default</span>; </span><br><span class="line">X(<span class="keyword">int</span> i)&#123; </span><br><span class="line">a = i; </span><br><span class="line">&#125;     </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="keyword">int</span> a; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>Defaulted 函数特性仅适用于类的特殊成员函数（四个），且该特殊成员函数没有默认参数。</li><li>Defaulted 函数既可以在类体里（inline）定义，也可以在类体外（out-of-line）定义。例如： </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span> </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">X() = <span class="keyword">default</span>; <span class="comment">//Inline defaulted 默认构造函数</span></span><br><span class="line">X(<span class="keyword">const</span> X&amp;); </span><br><span class="line">X&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp;); </span><br><span class="line">~X() = <span class="keyword">default</span>;  <span class="comment">//Inline defaulted 析构函数</span></span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">X::X(<span class="keyword">const</span> X&amp;) = <span class="keyword">default</span>;<span class="comment">//Out-of-line defaulted 拷贝构造函数</span></span><br><span class="line">X&amp; X::<span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp;) = <span class="keyword">default</span>;  <span class="comment">//Out-of-line defaulted 拷贝赋值运算符</span></span><br></pre></td></tr></table></figure><ul><li>参考链接里有<strong>关于 delete 指向派生类对象指针时的内存泄漏问题</strong>，值得学习。</li></ul><h3 id="2、Deleted-函数"><a href="#2、Deleted-函数" class="headerlink" title="2、Deleted 函数"></a>2、Deleted 函数</h3><p>为了能够让程序员显式的禁用某个函数，C++11 标准引入了一个新特性：deleted 函数。程序员只需在函数声明后加上“=delete;”，就可将该函数禁用。例如，我们可以将类 X 的拷贝构造函数以及拷贝赋值操作符声明为 deleted 函数，就可以禁止类 X 对象之间的拷贝和赋值。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span>            </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">X(); </span><br><span class="line">X(<span class="keyword">const</span> X&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 声明拷贝构造函数为 deleted 函数</span></span><br><span class="line">X&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> X &amp;) = <span class="keyword">delete</span>; <span class="comment">// 声明拷贝赋值操作符为 deleted 函数</span></span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">X x1; </span><br><span class="line">X x2=x1;<span class="comment">// 错误，拷贝构造函数被禁用</span></span><br><span class="line">X x3;</span><br><span class="line">x3=x1;<span class="comment">// 错误，拷贝赋值操作符被禁用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Deleted 函数特性还可用于禁用类的某些转换构造函数，从而避免不期望的类型转换。 如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">X(<span class="keyword">double</span>);              </span><br><span class="line">X(<span class="keyword">int</span>) = <span class="keyword">delete</span>;     </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="function">X <span class="title">x1</span><span class="params">(<span class="number">1.2</span>)</span></span>;        </span><br><span class="line"><span class="function">X <span class="title">x2</span><span class="params">(<span class="number">2</span>)</span></span>;<span class="comment">// 错误，参数为整数 int 类型的转换构造函数被禁用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Deleted 函数特性还可以用来禁用某些用户自定义的类的 new 操作符，从而避免在自由存储区创建类的对象。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= <span class="keyword">delete</span>; </span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>) = <span class="keyword">delete</span>; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">X *pa = <span class="keyword">new</span> X;<span class="comment">// 错误，new 操作符被禁用</span></span><br><span class="line">X *pb = <span class="keyword">new</span> X[<span class="number">10</span>];<span class="comment">// 错误，new[] 操作符被禁用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>必须在函数第一次声明的时候将其声明为 deleted 函数，否则编译器会报错。即对于类的成员函数而言，deleted 函数必须在类体里（inline）定义，而不能在类体外（out-of-line）定义。 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/aix/library/1212_lufang_c11new/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C++11 标准新特性：Defaulted 和 Deleted 函数&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1、Defaulted函数&quot;&gt;&lt;a href=&quot;#1、Defaulted函数&quot; class=&quot;headerlink&quot; title=&quot;1、Defaulted函数&quot;&gt;&lt;/a&gt;1、Defaulted函数&lt;/h3&gt;&lt;p&gt;C++ 的类有四类特殊成员函数，它们分别是：默认构造函数、析构函数、拷贝构造函数以及拷贝赋值运算符。这些类的特殊成员函数负责创建、初始化、销毁，或者拷贝类的对象。&lt;/p&gt;
&lt;p&gt;如果程序员没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，则编译器会隐式的为这个类生成一个默认的特殊成员函数。 如：&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://niliqiang.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://niliqiang.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--树</title>
    <link href="https://niliqiang.github.io/2019/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
    <id>https://niliqiang.github.io/2019/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</id>
    <published>2019-11-25T09:47:39.000Z</published>
    <updated>2020-03-21T12:43:57.510Z</updated>
    
    <content type="html"><![CDATA[<h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>树（Tree）是 n（n &gt;= 0）个结点的有限集，n = 0 时称为空树。</p><p>在任意一棵非空树中：</p><ul><li><p>有且仅有一个特定的根节点（Root），不可能存在多个根结点。</p></li><li><p>当 n &gt; 1 时，其余结点可以分为 m（m &gt; 0）个互不相交的有限集 T<sub>1</sub>、T<sub>2</sub>、······、T<sub>m</sub>，其中每一个集合本身又是一个树，并且称为根的子树（SubTree），如下图所示。</p></li></ul><a id="more"></a><p><img src="/2019/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/tree.PNG" alt="树的定义"></p><ul><li>当 m&gt;0 时，子树的个数没有限制，但它们一定是互不相交的。</li></ul><h4 id="结点分类"><a href="#结点分类" class="headerlink" title="结点分类"></a>结点分类</h4><p>树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为<strong>结点的度（Degree）</strong>。度为 0 的结点称为<strong>叶结点（Leaf）或终端结点</strong>；度不为 0 的结点称为<strong>非终端结点或分支结点</strong>。除根结点之外，分支结点也称为<strong>内部结点</strong>。树的度是树内各结点的度的最大值。</p><p><img src="/2019/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/结点分类.PNG" alt="结点分类"></p><h4 id="结点间关系"><a href="#结点间关系" class="headerlink" title="结点间关系"></a>结点间关系</h4><p>结点的子树的根称为该结点的<strong>孩子（Child）</strong>，相应地，该结点称为孩子的<strong>双亲（Parent）</strong>。同一个双亲的孩子之间互称<strong>兄弟（Sibling）</strong>。结点的<strong>祖先</strong>是从根到该结点所经分支上的所有结点。所以对于 H 来说，D，B，A 都是它的祖先。反之，<strong>以某结点为根的子树中的任一结点都称为该结点的子孙。</strong>所以 B 的子孙有 D，G，H，I。</p><p><img src="/2019/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/结点层次.PNG" alt="结点层次"></p><h4 id="树的其他相关概念"><a href="#树的其他相关概念" class="headerlink" title="树的其他相关概念"></a>树的其他相关概念</h4><ul><li><strong>结点的层次（Level）</strong>从根开始定义起，根为第一层，根的孩子为第二层。双亲在同一层的结点互为堂兄弟。显然上图中的 D，E，F 是堂兄弟，而 G，H，I，J 也是。树中结点的最大层次称为<strong>树的深度（Depth）或高度</strong>，当前树的深度为 4。</li><li>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为<strong>有序树</strong>，否则称为<strong>无序树</strong>。</li><li><strong>森林（Forest）是 m（m &gt;= 0）棵互不相交的树的集合。</strong>对树中每个结点而言，其子树的集合即为森林。</li></ul><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p>假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。其中 data 是数据域，存储结点的数据信息。而 parent 是指针域，存储该结点的双亲在数组中的下标。</p><p>| data | parent |</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 树的双亲表示法结构定义 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> TElemType;<span class="comment">/* 树结点的数据类型，暂定为整型 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>/* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;<span class="comment">/* 结点数据 */</span></span><br><span class="line">    <span class="keyword">int</span> parent;<span class="comment">/* 双亲位置 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PTree</span> /* 树结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];<span class="comment">/* 结点数组 */</span></span><br><span class="line">    <span class="keyword">int</span> r, n;<span class="comment">/* 根的位置和结点数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于根结点是没有双亲的，所以我们约定根结点的位置域设置为 -1，这也就意味着，我们所有的结点都存<br>有它双亲的位置，所以树双亲表示法如下表所示。</p><div class="table-container"><table><thead><tr><th style="text-align:center">下标</th><th style="text-align:center">data</th><th style="text-align:center">parent</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">A</td><td style="text-align:center">-1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">B</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">C</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">D</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">E</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">F</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">G</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">H</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">I</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">J</td><td style="text-align:center">4</td></tr></tbody></table></div><p>我们可以根据结点的 parent 指针很容易找到它的双亲结点，所用的时间复杂度为O(1)，直到 parent 为 -1 时，表示找到了树结点的根。这样的存储结构有一个问题就是要遍历整个结构才能找到结点的孩子。</p><p><strong>改进方法：</strong></p><p>增加一个结点最左边孩子的域（长子域），这样就可以很容易找到结点的孩子。如果没有孩子的结点，这个长子域就设置为 -1，如下表所示。</p><div class="table-container"><table><thead><tr><th style="text-align:center">下标</th><th style="text-align:center">data</th><th style="text-align:center">parent</th><th style="text-align:center">firstchild</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">A</td><td style="text-align:center">-1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">B</td><td style="text-align:center">0</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">C</td><td style="text-align:center">0</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">D</td><td style="text-align:center">1</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">E</td><td style="text-align:center">2</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">F</td><td style="text-align:center">2</td><td style="text-align:center">-1</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">G</td><td style="text-align:center">3</td><td style="text-align:center">-1</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">H</td><td style="text-align:center">3</td><td style="text-align:center">-1</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">I</td><td style="text-align:center">3</td><td style="text-align:center">-1</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">J</td><td style="text-align:center">4</td><td style="text-align:center">-1</td></tr></tbody></table></div><p>对于有 0 个或 1 个孩子结点来说，这样的结构是解决了要找结点孩子的问题了。但如果结点的孩子很多，超过了 2 个。我们又关注结点的双亲、又关注结点的孩子、还关注结点的兄弟，而且对时间遍历要求还比较高，那么我们还可以把此结构扩展为有双亲域、长子域、再有右兄弟域。</p><p>由以上分析过程可以看出，存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于基于该存储结构的运箅是否适合、是否方便，时间复杂度好不好等。</p><h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><p>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中毎个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。由于每个结点的度（结点孩子个数）不同，所以有两种方案：</p><p><strong>1. 指针域的个数就等于树的度</strong></p><p>| data | child1 | child2 | child3 | ······ | childd |</p><p>其中 data 是数据域。child1 到 childd 是指针域，用来指向该结点的孩子结点。</p><p>这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。不过如果树的各结点度相差很小时，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。</p><p><strong>2. 每个结点指针域的个数等于该结点的度</strong></p><p>专门取一个位置来存储结点指针域的个数：</p><p>| data | degree | child1 | child2 | child3 | ······ | childd |</p><p>其中 data 为数据域，degree 为度域，也就是存储该结点的孩子结点的个数，child1 到 childd 为指针域，指向该结点的各个孩子的结点。</p><p>这种方法克服了浪费空间的缺点，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。</p><p><strong>更好的方法：</strong></p><p>把每个结点放到一个顺序存储结构的数组中，再对每个结点的孩子建立一个单链表体现它们的关系。</p><p>具体办法是，把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。如下图所示。</p><p><img src="/2019/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/树的孩子表示法.PNG" alt="树的孩子表示法"></p><p>上图中有两种结点结构，一个是表头数组的表头结点：| data | firstchild |</p><p>其中 data 是数据域，存储某结点的数据信息。firstchild 是头指针域，存储该结点的孩子链表的头指针。</p><p>另一个是孩子链表的孩子结点：| child | next |</p><p>其中 child 是数据域，用来存储某个结点在表头数组中的下标。next 是指针域，用来存储指向某结点的下一个孩子结点的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 树的孩子表示法结构定义 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>/* 孩子结点 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">CTNode *ChildPtr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTBox</span> /* 表头结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTree</span> /* 树结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];<span class="comment">/* 结点数组 */</span></span><br><span class="line">    <span class="keyword">int</span> r, n;<span class="comment">/* 根的位置和结点数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。</p><p>如果想要知道某个结点的双亲是谁，只需在表头结构中加入双亲位置指针域，存储该结点的双亲在数组中的下标即可（| data | parent | firstchild |），这种方法被称为双亲孩子表示法。</p><h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h4><p>从树结点的兄弟的角度出发研究树的存储结构，我们可以发现，任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。</p><p>| data | firstchild | rightsib |</p><p>其中 data 是数据域，firstchild 为指针域，存储该结点的第一个孩子结点的存储地址，rightsib 是指针域，存储该结点的右兄弟结点的存储地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 树的孩子兄弟表示法结构定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">rightsib</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树。如下图所示。</p><p><img src="/2019/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/树的孩子兄弟表示法.PNG" alt="树的孩子兄弟表示法"></p><p>二叉树的内容将在之后介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;树的定义&quot;&gt;&lt;a href=&quot;#树的定义&quot; class=&quot;headerlink&quot; title=&quot;树的定义&quot;&gt;&lt;/a&gt;树的定义&lt;/h3&gt;&lt;p&gt;树（Tree）是 n（n &amp;gt;= 0）个结点的有限集，n = 0 时称为空树。&lt;/p&gt;
&lt;p&gt;在任意一棵非空树中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有且仅有一个特定的根节点（Root），不可能存在多个根结点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当 n &amp;gt; 1 时，其余结点可以分为 m（m &amp;gt; 0）个互不相交的有限集 T&lt;sub&gt;1&lt;/sub&gt;、T&lt;sub&gt;2&lt;/sub&gt;、······、T&lt;sub&gt;m&lt;/sub&gt;，其中每一个集合本身又是一个树，并且称为根的子树（SubTree），如下图所示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://niliqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://niliqiang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://niliqiang.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux 中编译安装 PTPd v2</title>
    <link href="https://niliqiang.github.io/2019/02/27/Linux-%E4%B8%AD%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85-PTPd-v2/"/>
    <id>https://niliqiang.github.io/2019/02/27/Linux-%E4%B8%AD%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85-PTPd-v2/</id>
    <published>2019-02-27T01:44:47.000Z</published>
    <updated>2020-03-21T12:45:18.209Z</updated>
    
    <content type="html"><![CDATA[<p>Step 1：进入 ptpd 目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ptpd</span><br></pre></td></tr></table></figure><p>Step 2：如果源文件是从 Github 仓库 clone 下来的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoreconf -vi</span><br></pre></td></tr></table></figure><p>Step 3：ptpd 的特性和依赖配置（默认配置）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><a id="more"></a><p>Step 4：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p><strong>参考链接：</strong></p><p><a href="https://raw.githubusercontent.com/ptpd/ptpd/master/INSTALL" target="_blank" rel="noopener">PTP Daemon Version 2 Build and Installation Instructions</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Step 1：进入 ptpd 目录&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; ptpd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Step 2：如果源文件是从 Github 仓库 clone 下来的&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;autoreconf -vi&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Step 3：ptpd 的特性和依赖配置（默认配置）&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;./configure&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://niliqiang.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://niliqiang.github.io/tags/Linux/"/>
    
      <category term="PTP" scheme="https://niliqiang.github.io/tags/PTP/"/>
    
  </entry>
  
  <entry>
    <title>srsUE 不使用 SIM 卡连接 Internet</title>
    <link href="https://niliqiang.github.io/2018/11/29/srsUE-%E4%B8%8D%E4%BD%BF%E7%94%A8-SIM-%E5%8D%A1%E8%BF%9E%E6%8E%A5-Internet/"/>
    <id>https://niliqiang.github.io/2018/11/29/srsUE-%E4%B8%8D%E4%BD%BF%E7%94%A8-SIM-%E5%8D%A1%E8%BF%9E%E6%8E%A5-Internet/</id>
    <published>2018-11-29T13:00:38.000Z</published>
    <updated>2020-03-21T12:47:26.145Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. 实验环境：</strong></p><p>Celluar SDR：srsLTE</p><p>SDR 平台：USRP B210</p><p>PC 机操作系统：Ubuntu 14.04</p><p><strong>2. 实验步骤</strong></p><p>注意：以下操作步骤建立在srsLTE成功搭建的基础之上</p><a id="more"></a><p>Step 1:</p><p>Make sure that you’ve masqueraded the outgoing interface at the EPC. There is a convenience script for this at “srsLTE/srsepc/srsepc_if_mask.sh”.</p><p>如果你的 EPC 端物理网卡名称是“eth0”，在 EPC 端执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo srsLTE/srsepc/srsepc_if_mask.sh eth0</span><br></pre></td></tr></table></figure><p>Step 2:</p><p>Make sure you’ve set your default gateway at the UE. You can check your default gateway by doing “route -n” and you can add a gw by doing “route add default gw {SGI-IP-ADDRESS} {TUN-SRSUE-INTERFACE}”.</p><p>将 UE 端的默认网关设置为 EPC 端的 IP 地址。如果你的 EPC 端 IP 地址为 172.16.0.1，UE 端的虚拟网卡名称为 tun_srsue，在 UE 端执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo route add default gw 172.16.0.1 tun_srsue</span><br></pre></td></tr></table></figure><p>Step 3:</p><p>If you are having DNS issues, make sure your DNS server is set up correctly. There is a discussion on how to do this for ubuntu here: <a href="https://askubuntu.com/questions/130452/how-do-i-add-a-dns-server-via-resolv-conf" target="_blank" rel="noopener">https://askubuntu.com/questions/130452/how-do-i-add-a-dns-server-via-resolv-conf</a><br>On ubuntu 16.04, what worked for me was to disable the network manager, update “/etc/resolvconf/resolv.conf.d/head” and run “sudo resolvconf -u”; but there are a few different ways to do this.</p><p><strong>参考资料：</strong></p><p><a href="http://www.softwareradiosystems.com/pipermail/srslte-users/2018-March/001454.html" target="_blank" rel="noopener">[srslte-users] ue can not connect to the internet</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1. 实验环境：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Celluar SDR：srsLTE&lt;/p&gt;
&lt;p&gt;SDR 平台：USRP B210&lt;/p&gt;
&lt;p&gt;PC 机操作系统：Ubuntu 14.04&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 实验步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意：以下操作步骤建立在srsLTE成功搭建的基础之上&lt;/p&gt;
    
    </summary>
    
    
      <category term="srsLTE" scheme="https://niliqiang.github.io/categories/srsLTE/"/>
    
    
      <category term="srsLTE" scheme="https://niliqiang.github.io/tags/srsLTE/"/>
    
  </entry>
  
  <entry>
    <title>srsLTE 源码学习之 PLMN 搜索、小区搜索流程</title>
    <link href="https://niliqiang.github.io/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/"/>
    <id>https://niliqiang.github.io/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/</id>
    <published>2018-08-08T07:35:20.000Z</published>
    <updated>2020-03-21T12:44:47.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h3><p>Celluar SDR：srsLTE</p><p>SDR 平台：USRP B210</p><p>看源码软件：Source Insight 4.0</p><p>由于应用方向和时间关系，暂不对物理层的源码展开过多研究。</p><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p><strong>1. rrc::plmn_search()</strong><br>从 srsLTE 的源码来看，PLMN（ Public Land Mobile Network ）搜索过程包含了小区搜索的过程。</p><a id="more"></a><p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180808102754702.png" alt="srsLTE\srsue\src\upper\rrc.cc"></p><p><strong>2. rrc::cell_search()</strong></p><p>下图中的 phy-&gt;cell_search(&amp;new_cell) 调用了物理层与RRC层的接口函数 cell_search，其所在文件的目录为：srsLTE\srsue\src\phy\phch_recv.cc。该函数的主要功能是获取小区物理 ID、完成下行同步、接收并解码 MIB，同步系统帧号（ SFN ）、完成小区驻留以及 获取SIB1 等；如果在任何的频段内都没有找到小区，则返回 CELL_NOT_FOUND；如果在搜索的过程中出现错误，则返回 ERROR。</p><p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180808103356381.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p><p>如果小区搜索结果为 CELL_FOUND，则开始设置 serving cell，不过在设置 serving cell 之前，要先添加邻区。</p><p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180808112303255.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p><p><strong>3. rrc::add_neighbour_cell() &amp; rrc::find_neighbour_cell()</strong></p><p>初始状态不存在 neighbour cell, 所以 neighbour_cells.size() = 0, 即 cell_idx = -1。</p><p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180809192446539.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p><p>注意两次的 rrc::add_neighbour_cell() 并不是同一个函数。</p><p>函数 rrc::add_neighbour_cell(phy_interface_rrc::phy_cell_t phy_cell, float rsrp) 的运行结果为  return add_neighbour_cell(new_cell); 如下图所示。</p><p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/2018080919252997.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p><p><strong>4. rrc::add_neighbour_cell() → rrc::cell_search() → rrc::set_serving_cell()</strong></p><p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180806101811166.png" alt="srsLTE\srsue\src\upper\rrc.cc"></p><p>函数 rrc::set_serving_cell() 中程序的流程比较简单，这里不做过多叙述。</p><p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180809192611382.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p><p><strong>5. rrc::set_serving_cell() → rrc::cell_search()</strong></p><p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180809192647918.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p><p><strong>6. rrc::cell_search() → rrc::si_acquire() → rrc::sib_start_tti() → rrc::si_acquire()</strong></p><p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180809192725489.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p><p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180809192739727.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p><p><strong>7. rrc::si_acquire() → rrc::cell_search()</strong></p><p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180809192808261.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p><p><strong>8. rrc::cell_search() → rrc::plmn_search() → rrc::process_phy_meas() → rrc::plmn_search()</strong></p><p>小区搜索结果为 CELL_FOUND，SIB1 已接收。</p><p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180808151237881.png" alt="srsLTE\srsue\src\upper\rrc.cc"></p><p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180808153357215.png" alt="srsLTE\srsue\src\upper\rrc.cc"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于程序在运行的过程中，涉及到了多线程的问题，所以为了更好地了解程序的运行过程，最好参照程序运行的 log 进行分析。</p><p>由于本人能力有限，可能会出现错误，如有错误或者疑问，欢迎大家指出。 谢谢！</p><p><strong>参考文献：</strong></p><p><a href="https://blog.csdn.net/m_052148/article/details/51273636" target="_blank" rel="noopener">LTE小区搜索-物理小区ID和同步信号PSS、SSS</a></p><p><a href="https://blog.csdn.net/m_052148/article/details/51303775" target="_blank" rel="noopener">LTE系统信息（1）-MIB</a></p><p><a href="https://blog.csdn.net/m_052148/article/details/52832807" target="_blank" rel="noopener">LTE系统信息（2）-SIB的周期调度</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实验环境：&quot;&gt;&lt;a href=&quot;#实验环境：&quot; class=&quot;headerlink&quot; title=&quot;实验环境：&quot;&gt;&lt;/a&gt;实验环境：&lt;/h3&gt;&lt;p&gt;Celluar SDR：srsLTE&lt;/p&gt;
&lt;p&gt;SDR 平台：USRP B210&lt;/p&gt;
&lt;p&gt;看源码软件：Source Insight 4.0&lt;/p&gt;
&lt;p&gt;由于应用方向和时间关系，暂不对物理层的源码展开过多研究。&lt;/p&gt;
&lt;h3 id=&quot;流程分析&quot;&gt;&lt;a href=&quot;#流程分析&quot; class=&quot;headerlink&quot; title=&quot;流程分析&quot;&gt;&lt;/a&gt;流程分析&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1. rrc::plmn_search()&lt;/strong&gt;&lt;br&gt;从 srsLTE 的源码来看，PLMN（ Public Land Mobile Network ）搜索过程包含了小区搜索的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="srsLTE" scheme="https://niliqiang.github.io/categories/srsLTE/"/>
    
    
      <category term="LTE" scheme="https://niliqiang.github.io/tags/LTE/"/>
    
      <category term="srsLTE" scheme="https://niliqiang.github.io/tags/srsLTE/"/>
    
  </entry>
  
  <entry>
    <title>LTE 学习之传输分集中的层映射与预编码</title>
    <link href="https://niliqiang.github.io/2018/07/28/LTE-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%88%86%E9%9B%86%E4%B8%AD%E7%9A%84%E5%B1%82%E6%98%A0%E5%B0%84%E4%B8%8E%E9%A2%84%E7%BC%96%E7%A0%81/"/>
    <id>https://niliqiang.github.io/2018/07/28/LTE-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%88%86%E9%9B%86%E4%B8%AD%E7%9A%84%E5%B1%82%E6%98%A0%E5%B0%84%E4%B8%8E%E9%A2%84%E7%BC%96%E7%A0%81/</id>
    <published>2018-07-28T05:43:42.000Z</published>
    <updated>2020-03-21T12:45:01.720Z</updated>
    
    <content type="html"><![CDATA[<p>传输分集（ transmit diversity ）的目的是抗衰落，用于提高信号传输的可靠性，主要针对小区边缘用户。为了实现传输分集，需要通过层映射将调制后的数据（ symbols ）分到不同的层，再通过预编码将数据映射到天线端口。</p><p><strong>在这里我们假设调制方式为 QPSK，天线端口数为两个。</strong></p><h3 id="层映射（-Layer-mapping-）"><a href="#层映射（-Layer-mapping-）" class="headerlink" title="层映射（ Layer mapping ）"></a>层映射（ Layer mapping ）</h3><p>因为每个码字长度为 32 比特，所以调制之后会有 16 个 symbols，由于层映射的层数等于天线的端口数，所以层映射的过程就是将 16 个 symbols 分到两层，分层的方法如下图所示：</p><a id="more"></a><p><img src="/2018/07/28/LTE-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%88%86%E9%9B%86%E4%B8%AD%E7%9A%84%E5%B1%82%E6%98%A0%E5%B0%84%E4%B8%8E%E9%A2%84%E7%BC%96%E7%A0%81/20180728111800623.png" alt="img"></p><p>其中，$M_{symb}^{layer}$是每层的 symbols 数目，即 $M_{symb}^{layer}$ = 8，$M_{symb}^{(0))}$为第“0”个码字调制后的 symbols 数，即 $M_{symb}^{(0))}$ = 16。</p><h3 id="预编码（-Precoding-）"><a href="#预编码（-Precoding-）" class="headerlink" title="预编码（ Precoding ）"></a>预编码（ Precoding ）</h3><p>调制后的数据层映射之后要进行预编码，预编码将数据映射到天线端口。</p><p>预编码输出：</p><script type="math/tex; mode=display">y(i)=[y^{(0)}(i), y^{(1)}(i)]^T, i=0,1,...,M^{ap}_{symb} - 1</script><p>其中，$M^{ap}_{symb}$为每一个天线端口的 symbols 数，即 $M^{ap}_{symb} = 2*M_{symb}^{layer} = 16$。</p><p>预编码公式为：</p><p><img src="/2018/07/28/LTE-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%88%86%E9%9B%86%E4%B8%AD%E7%9A%84%E5%B1%82%E6%98%A0%E5%B0%84%E4%B8%8E%E9%A2%84%E7%BC%96%E7%A0%81/20180728114808801.png" alt="img"></p><p>其中，$i=0,1,…,M^{ap}_{symb} - 1$</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>虽然层映射之后，每一层只有一半的 symbols（以 2 个天线端口为例）， 但是预编码之后每个天线端口传输的数据包含所有的 symbols，只是数据的传输形式不同（推导一下预编码的输出结果就能看出来了），也就是说传输分集是多个天线端口发送相同的数据（但是数据形式不同）。</p><p><strong>参考材料：</strong></p><p>TS36.211 v10.3</p><p><a href="https://blog.csdn.net/liu_xuxiang/article/details/81173375" target="_blank" rel="noopener">srsLTE - PCFICH 源码解析 02</a></p><p><a href="https://blog.csdn.net/liu048074leiliu/article/details/47255777" target="_blank" rel="noopener">LTE中的层映射的主要作用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传输分集（ transmit diversity ）的目的是抗衰落，用于提高信号传输的可靠性，主要针对小区边缘用户。为了实现传输分集，需要通过层映射将调制后的数据（ symbols ）分到不同的层，再通过预编码将数据映射到天线端口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在这里我们假设调制方式为 QPSK，天线端口数为两个。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;层映射（-Layer-mapping-）&quot;&gt;&lt;a href=&quot;#层映射（-Layer-mapping-）&quot; class=&quot;headerlink&quot; title=&quot;层映射（ Layer mapping ）&quot;&gt;&lt;/a&gt;层映射（ Layer mapping ）&lt;/h3&gt;&lt;p&gt;因为每个码字长度为 32 比特，所以调制之后会有 16 个 symbols，由于层映射的层数等于天线的端口数，所以层映射的过程就是将 16 个 symbols 分到两层，分层的方法如下图所示：&lt;/p&gt;
    
    </summary>
    
    
      <category term="LTE" scheme="https://niliqiang.github.io/categories/LTE/"/>
    
    
      <category term="LTE" scheme="https://niliqiang.github.io/tags/LTE/"/>
    
  </entry>
  
</feed>
