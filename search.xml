<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++11 中的 Defaulted 和 Deleted 函数</title>
    <url>/2019/11/25/C-11-%E4%B8%AD%E7%9A%84-Defaulted-%E5%92%8C-Deleted-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.ibm.com/developerworks/cn/aix/library/1212_lufang_c11new/index.html" target="_blank" rel="noopener">C++11 标准新特性：Defaulted 和 Deleted 函数</a></p>
</blockquote><h3 id="1、Defaulted函数"><a href="#1、Defaulted函数" class="headerlink" title="1、Defaulted函数"></a>1、Defaulted函数</h3><p>C++ 的类有四类特殊成员函数，它们分别是：默认构造函数、析构函数、拷贝构造函数以及拷贝赋值运算符。这些类的特殊成员函数负责创建、初始化、销毁，或者拷贝类的对象。如果程序员没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，则编译器会隐式的为这个类生成一个默认的特殊成员函数。 如：</p><a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">	<span class="keyword">int</span> a; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">X x;</span><br></pre></td></tr></table></figure>
<p>但是，如果程序员为类 X 显式的自定义了非默认构造函数（带参数），却没有定义默认构造函数的时候，编译器将不再会为它隐式的生成默认构造函数。如果需要用到默认构造函数来创建类的对象时，程序员必须自己显式的定义默认构造函数。 如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	X()&#123;&#125;;  <span class="comment">// 手动定义默认构造函数</span></span><br><span class="line">	X(<span class="keyword">int</span> i)&#123; </span><br><span class="line">		a = i; </span><br><span class="line">	&#125;     </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">	<span class="keyword">int</span> a; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X x;	<span class="comment">// 正确，默认构造函数 X::X() 存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中的矛盾之处：</p>
<ul>
<li>原本期望编译器自动生成的默认构造函数需要程序员手动编写，程序员的工作量加大。</li>
<li>手动编写的默认构造函数的代码执行效率比编译器自动生成的默认构造函数低。</li>
</ul>
<p>为了解决上述矛盾，C++ 11 中提出了 Defaulted 函数。程序员只需在函数声明后加上 “=default;”，就可将该函数声明为 defaulted 函数，<strong>编译器将为显式声明的 defaulted 函数自动生成函数体</strong>。如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	X()= <span class="keyword">default</span>; </span><br><span class="line">	X(<span class="keyword">int</span> i)&#123; </span><br><span class="line">		a = i; </span><br><span class="line">	&#125;     </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">	<span class="keyword">int</span> a; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>Defaulted 函数特性仅适用于类的特殊成员函数（四个），且该特殊成员函数没有默认参数。</li>
<li><p>Defaulted 函数既可以在类体里（inline）定义，也可以在类体外（out-of-line）定义。例如： </p>
</li>
<li><p>```c++<br>class X{<br>public:  </p>
<pre><code>X() = default; //Inline defaulted 默认构造函数
X(const X&amp;); 
X&amp; operator = (const X&amp;); 
~X() = default;  //Inline defaulted 析构函数
</code></pre><p>}; </p>
<p>X::X(const X&amp;) = default;    //Out-of-line defaulted    拷贝构造函数<br>X&amp; X::operator = (const X&amp;) = default;    //Out-of-line defaulted    拷贝赋值运算符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 参考链接里有**关于 <span class="keyword">delete</span> 指向派生类对象指针时的内存泄漏问题**，值得学习。</span><br><span class="line"></span><br><span class="line">### <span class="number">2</span>、Deleted 函数</span><br><span class="line"></span><br><span class="line">为了能够让程序员显式的禁用某个函数，C++<span class="number">11</span> 标准引入了一个新特性：deleted 函数。程序员只需在函数声明后加上“=<span class="keyword">delete</span>;”，就可将该函数禁用。例如，我们可以将类 X 的拷贝构造函数以及拷贝赋值操作符声明为 deleted 函数，就可以禁止类 X 对象之间的拷贝和赋值。如：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span>            </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	X(); </span><br><span class="line">	X(<span class="keyword">const</span> X&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 声明拷贝构造函数为 deleted 函数</span></span><br><span class="line">	X&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> X &amp;) = <span class="keyword">delete</span>; <span class="comment">// 声明拷贝赋值操作符为 deleted 函数</span></span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">	X x1; </span><br><span class="line">	X x2=x1;	<span class="comment">// 错误，拷贝构造函数被禁用</span></span><br><span class="line">	X x3;</span><br><span class="line">	x3=x1;		<span class="comment">// 错误，拷贝赋值操作符被禁用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Deleted 函数特性还可用于禁用类的某些转换构造函数，从而避免不期望的类型转换。 如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	X(<span class="keyword">double</span>);              </span><br><span class="line">	X(<span class="keyword">int</span>) = <span class="keyword">delete</span>;     </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">	<span class="function">X <span class="title">x1</span><span class="params">(<span class="number">1.2</span>)</span></span>;        </span><br><span class="line">	<span class="function">X <span class="title">x2</span><span class="params">(<span class="number">2</span>)</span></span>;	<span class="comment">// 错误，参数为整数 int 类型的转换构造函数被禁用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Deleted 函数特性还可以用来禁用某些用户自定义的类的 new 操作符，从而避免在自由存储区创建类的对象。如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= <span class="keyword">delete</span>; </span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>) = <span class="keyword">delete</span>; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">	X *pa = <span class="keyword">new</span> X;		<span class="comment">// 错误，new 操作符被禁用</span></span><br><span class="line">	X *pb = <span class="keyword">new</span> X[<span class="number">10</span>];	<span class="comment">// 错误，new[] 操作符被禁用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>必须在函数第一次声明的时候将其声明为 deleted 函数，否则编译器会报错。即对于类的成员函数而言，deleted 函数必须在类体里（inline）定义，而不能在类体外（out-of-line）定义。 </li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Temp</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>HexoTemp</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 中编译安装 PTPd v2</title>
    <url>/2019/02/27/Linux-%E4%B8%AD%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85-PTPd-v2/</url>
    <content><![CDATA[<p>Step 1：进入 ptpd 目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ptpd</span><br></pre></td></tr></table></figure><p>Step 2：如果源文件是从 Github 仓库 clone 下来的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">autoreconf -vi</span><br></pre></td></tr></table></figure><p>Step 3：ptpd 的特性和依赖配置（默认配置）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>Step 4：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p><strong>参考链接：</strong></p><p><a href="https://raw.githubusercontent.com/ptpd/ptpd/master/INSTALL" target="_blank" rel="noopener">PTP Daemon Version 2 Build and Installation Instructions</a></p>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>PTP</tag>
      </tags>
  </entry>
  <entry>
    <title>srsUE 不使用 SIM 卡连接 Internet</title>
    <url>/2018/11/29/srsUE-%E4%B8%8D%E4%BD%BF%E7%94%A8-SIM-%E5%8D%A1%E8%BF%9E%E6%8E%A5-Internet/</url>
    <content><![CDATA[<p><strong>1. 实验环境：</strong></p><p>Celluar SDR：srsLTE</p><p>SDR 平台：USRP B210</p><p>PC 机操作系统：Ubuntu 14.04</p><p><strong>2. 实验步骤</strong></p><p>注意：以下操作步骤建立在srsLTE成功搭建的基础之上</p><p>Step 1:</p><p>Make sure that you’ve masqueraded the outgoing interface at the EPC. There is a convenience script for this at “srsLTE/srsepc/srsepc_if_mask.sh”.</p><a id="more"></a>







<p>如果你的 EPC 端物理网卡名称是“eth0”，在 EPC 端执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo srsLTE/srsepc/srsepc_if_mask.sh eth0</span><br></pre></td></tr></table></figure>
<p>Step 2:</p>
<p>Make sure you’ve set your default gateway at the UE. You can check your default gateway by doing “route -n” and you can add a gw by doing “route add default gw {SGI-IP-ADDRESS} {TUN-SRSUE-INTERFACE}”.</p>
<p>将 UE 端的默认网关设置为 EPC 端的 IP 地址。如果你的 EPC 端 IP 地址为 172.16.0.1，UE 端的虚拟网卡名称为 tun_srsue，在 UE 端执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo route add default gw 172.16.0.1 tun_srsue</span><br></pre></td></tr></table></figure>
<p>Step 3:</p>
<p>If you are having DNS issues, make sure your DNS server is set up correctly. There is a discussion on how to do this for ubuntu here: <a href="https://askubuntu.com/questions/130452/how-do-i-add-a-dns-server-via-resolv-conf" target="_blank" rel="noopener">https://askubuntu.com/questions/130452/how-do-i-add-a-dns-server-via-resolv-conf</a><br>On ubuntu 16.04, what worked for me was to disable the network manager, update “/etc/resolvconf/resolv.conf.d/head” and run “sudo resolvconf -u”; but there are a few different ways to do this.</p>
<p><strong>参考资料：</strong></p>
<p><a href="http://www.softwareradiosystems.com/pipermail/srslte-users/2018-March/001454.html" target="_blank" rel="noopener">[srslte-users] ue can not connect to the internet</a></p>
]]></content>
      <categories>
        <category>srsLTE</category>
      </categories>
      <tags>
        <tag>srsLTE</tag>
      </tags>
  </entry>
  <entry>
    <title>srsLTE 源码学习之 PLMN 搜索、小区搜索流程</title>
    <url>/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h3><p>Celluar SDR：srsLTE</p><p>SDR 平台：USRP B210</p><p>看源码软件：Source Insight 4.0</p><p>由于应用方向和时间关系，暂不对物理层的源码展开过多研究。</p><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p><strong>1. rrc::plmn_search()</strong><br>从 srsLTE 的源码来看，PLMN（ Public Land Mobile Network ）搜索过程包含了小区搜索的过程。</p><a id="more"></a>




<p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180808102754702.png" alt="srsLTE\srsue\src\upper\rrc.cc"></p>
<p><strong>2. rrc::cell_search()</strong></p>
<p>下图中的 phy-&gt;cell_search(&amp;new_cell) 调用了物理层与RRC层的接口函数 cell_search，其所在文件的目录为：srsLTE\srsue\src\phy\phch_recv.cc。该函数的主要功能是获取小区物理 ID、完成下行同步、接收并解码 MIB，同步系统帧号（ SFN ）、完成小区驻留以及 获取SIB1 等；如果在任何的频段内都没有找到小区，则返回 CELL_NOT_FOUND；如果在搜索的过程中出现错误，则返回 ERROR。</p>
<p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180808103356381.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p>
<p>如果小区搜索结果为 CELL_FOUND，则开始设置 serving cell，不过在设置 serving cell 之前，要先添加邻区。</p>
<p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180808112303255.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p>
<p><strong>3. rrc::add_neighbour_cell() &amp; rrc::find_neighbour_cell()</strong></p>
<p>初始状态不存在 neighbour cell, 所以 neighbour_cells.size() = 0, 即 cell_idx = -1。</p>
<p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180809192446539.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p>
<p>注意两次的 rrc::add_neighbour_cell() 并不是同一个函数。</p>
<p>函数 rrc::add_neighbour_cell(phy_interface_rrc::phy_cell_t phy_cell, float rsrp) 的运行结果为  return add_neighbour_cell(new_cell); 如下图所示。</p>
<p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/2018080919252997.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p>
<p><strong>4. rrc::add_neighbour_cell() → rrc::cell_search() → rrc::set_serving_cell()</strong></p>
<p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180806101811166.png" alt="srsLTE\srsue\src\upper\rrc.cc"></p>
<p>函数 rrc::set_serving_cell() 中程序的流程比较简单，这里不做过多叙述。</p>
<p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180809192611382.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p>
<p><strong>5. rrc::set_serving_cell() → rrc::cell_search()</strong></p>
<p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180809192647918.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p>
<p><strong>6. rrc::cell_search() → rrc::si_acquire() → rrc::sib_start_tti() → rrc::si_acquire()</strong></p>
<p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180809192725489.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p>
<p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180809192739727.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p>
<p><strong>7. rrc::si_acquire() → rrc::cell_search()</strong></p>
<p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180809192808261.jfif" alt="srsLTE\srsue\src\upper\rrc.cc"></p>
<p><strong>8. rrc::cell_search() → rrc::plmn_search() → rrc::process_phy_meas() → rrc::plmn_search()</strong></p>
<p>小区搜索结果为 CELL_FOUND，SIB1 已接收。</p>
<p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180808151237881.png" alt="srsLTE\srsue\src\upper\rrc.cc"></p>
<p><img src="/2018/08/08/srsLTE-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B-PLMN-%E6%90%9C%E7%B4%A2%E3%80%81%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E6%B5%81%E7%A8%8B/20180808153357215.png" alt="srsLTE\srsue\src\upper\rrc.cc"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于程序在运行的过程中，涉及到了多线程的问题，所以为了更好地了解程序的运行过程，最好参照程序运行的 log 进行分析。</p>
<p>由于本人能力有限，可能会出现错误，如有错误或者疑问，欢迎大家指出。 谢谢！</p>
<p><strong>参考文献：</strong></p>
<p><a href="https://blog.csdn.net/m_052148/article/details/51273636" target="_blank" rel="noopener">LTE小区搜索-物理小区ID和同步信号PSS、SSS</a></p>
<p><a href="https://blog.csdn.net/m_052148/article/details/51303775" target="_blank" rel="noopener">LTE系统信息（1）-MIB</a></p>
<p><a href="https://blog.csdn.net/m_052148/article/details/52832807" target="_blank" rel="noopener">LTE系统信息（2）-SIB的周期调度</a></p>
]]></content>
      <categories>
        <category>srsLTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>srsLTE</tag>
      </tags>
  </entry>
  <entry>
    <title>LTE 学习之传输分集中的层映射与预编码</title>
    <url>/2018/07/28/LTE-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%88%86%E9%9B%86%E4%B8%AD%E7%9A%84%E5%B1%82%E6%98%A0%E5%B0%84%E4%B8%8E%E9%A2%84%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>传输分集（ transmit diversity ）的目的是抗衰落，用于提高信号传输的可靠性，主要针对小区边缘用户。为了实现传输分集，需要通过层映射将调制后的数据（ symbols ）分到不同的层，再通过预编码将数据映射到天线端口。</p><p><strong>在这里我们假设调制方式为 QPSK，天线端口数为两个。</strong></p><h3 id="层映射（-Layer-mapping-）"><a href="#层映射（-Layer-mapping-）" class="headerlink" title="层映射（ Layer mapping ）"></a>层映射（ Layer mapping ）</h3><a id="more"></a>

<p>因为每个码字长度为 32 比特，所以调制之后会有 16 个 symbols，由于层映射的层数等于天线的端口数，所以层映射的过程就是将 16 个 symbols 分到两层，分层的方法如下图所示：</p>
<p><img src="20180728111800623.png" alt="img"></p>
<p>其中，$M_{symb}^{layer}$是每层的 symbols 数目，即 $M_{symb}^{layer}$ = 8，$M_{symb}^{(0))}$为第“0”个码字调制后的 symbols 数，即 $M_{symb}^{(0))}$ = 16。</p>
<h3 id="预编码（-Precoding-）"><a href="#预编码（-Precoding-）" class="headerlink" title="预编码（ Precoding ）"></a>预编码（ Precoding ）</h3><p>调制后的数据层映射之后要进行预编码，预编码将数据映射到天线端口。</p>
<p>预编码输出：</p>
<script type="math/tex; mode=display">
y(i)=[y^{(0)}(i), y^{(1)}(i)]^T, i=0,1,...,M^{ap}_{symb} - 1</script><p>其中，$M^{ap}_{symb}$为每一个天线端口的 symbols 数，即 $M^{ap}_{symb} = 2*M_{symb}^{layer} = 16$。</p>
<p>预编码公式为：</p>
<p><img src="20180728114808801.png" alt="img"></p>
<p>其中，$i=0,1,…,M^{ap}_{symb} - 1$</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>虽然层映射之后，每一层只有一半的 symbols（以 2 个天线端口为例）， 但是预编码之后每个天线端口传输的数据包含所有的 symbols，只是数据的传输形式不同（推导一下预编码的输出结果就能看出来了），也就是说传输分集是多个天线端口发送相同的数据（但是数据形式不同）。</p>
<p><strong>参考材料：</strong></p>
<p>TS36.211 v10.3</p>
<p><a href="https://blog.csdn.net/liu_xuxiang/article/details/81173375" target="_blank" rel="noopener">srsLTE - PCFICH 源码解析 02</a></p>
<p><a href="https://blog.csdn.net/liu048074leiliu/article/details/47255777" target="_blank" rel="noopener">LTE中的层映射的主要作用</a></p>
]]></content>
      <categories>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
      </tags>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
