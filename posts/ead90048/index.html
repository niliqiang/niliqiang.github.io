<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://niliqiang.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="图的定义图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。 注意：  线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点（Vertex）。 线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。在图结构中，不允许没有顶点。在定义中，若 V 是">
<meta name="keywords" content="数据结构,图">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构--图">
<meta property="og:url" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;index.html">
<meta property="og:site_name" content="niliqiang&#39;s Blog">
<meta property="og:description" content="图的定义图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。 注意：  线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点（Vertex）。 线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。在图结构中，不允许没有顶点。在定义中，若 V 是">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1577954859109.png">
<meta property="og:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1577954898647.png">
<meta property="og:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1577955726420.png">
<meta property="og:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1577955927359.png">
<meta property="og:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1577956023701.png">
<meta property="og:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1577957648958.png">
<meta property="og:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1577957670974.png">
<meta property="og:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1577958480369.png">
<meta property="og:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1577958506062.png">
<meta property="og:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1577958720925.png">
<meta property="og:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1578453974200.png">
<meta property="og:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1578558836503.png">
<meta property="og:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1578620201925.png">
<meta property="og:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1578628039919.png">
<meta property="og:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1578640691016.png">
<meta property="og:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1578649533784.png">
<meta property="og:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1578649563477.png">
<meta property="og:updated_time" content="2020-03-24T03:34:14.838Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;niliqiang.github.io&#x2F;posts&#x2F;ead90048&#x2F;1577954859109.png">

<link rel="canonical" href="https://niliqiang.github.io/posts/ead90048/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>数据结构--图 | niliqiang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="niliqiang's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">niliqiang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Welcome</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/niliqiang" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://niliqiang.github.io/posts/ead90048/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niliqiang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niliqiang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构--图
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-10 17:47:42" itemprop="dateCreated datePublished" datetime="2020-01-10T17:47:42+08:00">2020-01-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。</p>
<p>注意：</p>
<ul>
<li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，在<strong>图中数据元素，我们则称之为顶点（Vertex）</strong>。</li>
<li>线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。在<strong>图结构中，不允许没有顶点</strong>。在定义中，若 V 是顶点的集合，则强调了顶点集合 V 有穷非空（关于点集是否为空有争议）。</li>
</ul>
<a id="more"></a>
<ul>
<li>线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而<strong>图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的</strong>。</li>
</ul>
<p><strong>无向图</strong>：图中任意两个顶点之间的边都是无向边（顶点之间的边没有方向，用无序偶对($v_i, v_j$)表示）。<br><strong>有向图</strong>：图中任意两个顶点之间的边都是有向边（从顶点$v_i$ 到 $v_j$的边有方向，用有序偶对\&lt;$v_i, v_j$&gt;来表示，也称为弧，$v_i$为弧尾，$v_j$为弧头）。<br><strong>简单图</strong>：图中不存在顶点到其自身的边，且一条边不重复出现的图。<br><strong>无向完全图</strong>：无向图中任意两个顶点之间都存在边的图。<br><strong>有向完全图</strong>：有向图中任意两个顶点之间都存在方向互为相反的两条弧的图。<br><strong>稀疏图</strong>：有很少条边或者弧的图，反之称为稠密图。<br><strong>网（Network）</strong>：带权（weight，与图的边或者弧相关的数）的图</p>
<p>对于无向图，<strong>顶点v的度</strong>是和该顶点相关联的边的数目，记为TD(v)；<br>无向图的边数是各顶点度数和的一半。<br>对于有向图，以顶点v为头的弧的数目称为<strong>v的入度</strong>，记为ID(v)；以v为尾的弧的数目称为<strong>v的出度</strong>，记为OD(v)；<br>有向图的弧条数等于各顶点的出度和等于各顶点的入度和。</p>
<p>路径的长度是路径上的边或弧的数目。<br>第一个顶点到最后一个顶点相同的路径称为<strong>回路或环（Cycle）</strong>。序列中顶点不重复出现的路径称为<strong>简单路径</strong>。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为<strong>简单回路或简单环</strong>。</p>
<p>在无向图 G 中，如果从顶点$v_i$到顶点$v_j$有路径，则称$v_i$和$v_j$是连通的。如果对于<br>图中任意两个顶点 $v_i, v_j∈E$，$v_i$和$v_j$都是连通的，则称 G 是<strong>连通图</strong>。<br>无向图中的极大连通子图称为<strong>连通分量</strong>。它强调：</p>
<ul>
<li>要是子图；</li>
<li>子图要是联通的；</li>
<li>连通子图含有极大顶点数；</li>
<li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</li>
</ul>
<p>在有向图 G 中，如果对于每一对的$v_i, v_j∈V$、$v_i ≠ v_j$，从$v_i$和$v_j$和从$v_j$和$v_i$都存在路径，则称 G 是强连通图。有向图中的极大强连通子图称做有向图的强连通分量。</p>
<p>一个<strong>连通图的生成树</strong>是一个极小的连通子图，它含有图中全部的 n 个顶点，但只有足以构成一棵树的 n-1 条边。<br>如果一个有向图恰有一个顶点的入度为0, 其余顶点的入度均为 1, 则是一棵<strong>有向树</strong>。<br>一个<strong>有向图的生成森林</strong>由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</p>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。</p>
<p><img src="/posts/ead90048/1577954859109.png" alt="无向图-邻接矩阵"></p>
<p><img src="/posts/ead90048/1577954898647.png" alt="有向图-邻接矩阵"></p>
<p>缺点：对于边数相对顶点较少的图，对存储空间有较大浪费。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VEX		100		<span class="comment">// 最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AMGraph</span> &#123;</span></span><br><span class="line">	VertexType vexs[MAX_VEX];		<span class="comment">// 顶点表</span></span><br><span class="line">	EdgeType arc[MAX_VEX][MAX_VEX];	<span class="comment">// 邻接矩阵，可看做边表</span></span><br><span class="line">	<span class="keyword">int</span> num_vertexes, num_edges;		<span class="comment">// 图中当前的顶点数和边数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>对边或弧使用链式存储的方式来避免空间浪费的问题，这种数组与链表相结合的存储方法称为邻接表。<br>图中每个顶点$v_i$的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点$v_i$的边表，有向图则称为顶点$v_i$作为弧尾的出边表。</p>
<p><img src="/posts/ead90048/1577955726420.png" alt="无向图-邻接表"></p>
<p>有向图的<strong>逆邻接表</strong>：对每个顶点$v_i$都建立一个链接为$v_i$为弧头的表.</p>
<p><img src="/posts/ead90048/1577955927359.png" alt="无向图-邻接表"></p>
<p>对于带权值的网图，可以在边表结点定义中再增加一个 weight 的数据域，存储权值信息即可。</p>
<p><img src="/posts/ead90048/1577956023701.png" alt="无向图-邻接表-带权"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> adjvex;</span><br><span class="line">	EdgeType weight;</span><br><span class="line">	EdgeNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> &#123;</span></span><br><span class="line">	VertexType data;</span><br><span class="line">	EdgeNode&lt;EdgeType&gt; *firstedge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该结构体是上两个结构体的整合</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALGraph</span> &#123;</span></span><br><span class="line">	VertexNode&lt;VertexType, EdgeType&gt; adj_list[MAX_VEX];</span><br><span class="line">	<span class="keyword">int</span> num_vertexes, num_edges;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><p>十字链表：把邻接表与逆邻接表结合起来的存储方法。</p>
<p><img src="/posts/ead90048/1577957648958.png" alt="十字链表结点结构"></p>
<p><img src="/posts/ead90048/1577957670974.png" alt="有向图-十字链表"></p>
<p>十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以$v_i$为尾的弧，也容易找到以$v_i$为头的弧，因而容易求得顶点的出度和入度。而且它除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的，因此，在有向图的应用中，十字链表是非常好的数据结构模型。</p>
<h4 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h4><p><img src="/posts/ead90048/1577958480369.png" alt="邻接多重表结点结构"></p>
<p><img src="/posts/ead90048/1577958506062.png" alt="无向图-邻接多重表"></p>
<h4 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h4><p>边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组毎个数据元素由一条边的起点下标（begin）终点下标（end）和权（weight）组成。</p>
<p>边集数组关注的是边的集合，在边集数组中要查找一个顶点的度需要扫描整个边数组，效率并不高。因此它更适合对边依次进行处理的操作，而不适合对顶点相关的操作。</p>
<p><img src="/posts/ead90048/1577958720925.png" alt="有向图-边集数组-带权"></p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历 (Traversing Graph)。</p>
<h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p>深度优先遍历 (Depth_First_Search)，也称为深度优先搜索，简称为 DFS 。<br>深度优先遍历其实就是一个递归的过程，也是一棵树的前序遍历过程。<strong>它从图中某个顶点 v 出发，访问此顶点，然后从 v 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 v 有路径相通的顶点都被访问到。</strong>事实上，我们这里讲到的是连通图，对于非连通图，只需要对它的连通分量分别进行深度优先遍历，即在先前一个顶点进行一次深度优先遍历后，若图中尚有顶点未被访问，<strong>则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指示访问标志</span></span><br><span class="line"><span class="keyword">bool</span> visited_[MAX_VEX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵的深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(AMGraph&lt;VertexType, EdgeType&gt; *&amp;am_graph, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	visited_[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; am_graph-&gt;vexs[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; am_graph-&gt;num_vertexes; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (am_graph-&gt;arc[i][j] == <span class="number">1</span> &amp;&amp; !visited_[j]) &#123;  <span class="comment">//对未访问的邻接节点递归调用</span></span><br><span class="line">			DFS(am_graph, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(AMGraph&lt;VertexType, EdgeType&gt; *&amp;am_graph)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; am_graph-&gt;num_vertexes; i ++) &#123;</span><br><span class="line">		visited_[i] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; am_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!visited_[i]) &#123;  <span class="comment">//对未访问过的节点调用DFS，若是连通图，则只会调用一次</span></span><br><span class="line">			DFS(am_graph, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表的深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(ALGraph&lt;VertexType, EdgeType&gt; *&amp;al_graph, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	EdgeNode&lt;EdgeType&gt; *edge;</span><br><span class="line">	visited_[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; al_graph-&gt;vexs[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	edge = al_graph-&gt;adj_list[i].firstedge;</span><br><span class="line">	<span class="keyword">while</span> (edge) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!visited[edge-&gt;adjvex]) &#123;  <span class="comment">//对未访问的邻接节点递归调用</span></span><br><span class="line">			DFS(al_graph, edge-&gt;adjvex);</span><br><span class="line">		&#125;</span><br><span class="line">		edge = edge-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(ALGraph&lt;VertexType, EdgeType&gt; *&amp;al_graph)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; al_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line">		visited_[i] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; al_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!visited_[i]) &#123;  <span class="comment">//对未访问过的节点调用DFS，若是连通图，则只会调用一次</span></span><br><span class="line">			DFS(al_graph, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比两个不同存储结构的深度优先遍历算法，对于 n 个顶点 e 条边的图来说，邻接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此都需要$O(n^2)$的时间。而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是$O(n+e)$显然对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。</p>
<h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>广度优先遍历 (Breadth_First_Search)，又称为广度优先搜索，简称 BFS 。<br>如果说图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树的层序遍历。层序遍历之前需要将图稍微变形，变形原则是顶点 A 放置在最上第一层，让与它有边的顶点 B、F 为第二层，再让与 B 和 F 有边的顶点 C、I、G、E 为第三层，再将这四个顶点有边的 D、H 放在第四层。</p>
<p><img src="/posts/ead90048/1578453974200.png" alt="BFS"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	邻接矩阵的广度遍历算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverseAM</span><span class="params">(AMGraph&lt;VertexType, EdgeType&gt; *&amp;am_graph)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; vertex_queue;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; am_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line">		visited[i] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; am_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">			visited[i] = <span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; am_graph-&gt;vexs[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			vertex_queue.push(i);  <span class="comment">//顶点index入队列</span></span><br><span class="line">			<span class="keyword">while</span> (!vertex_queue.empty()) &#123;  <span class="comment">//若当前队列不为空</span></span><br><span class="line">				i = vertex_queue.front();  <span class="comment">//返回当前队列首元素</span></span><br><span class="line">				vertex_queue.pop();</span><br><span class="line">				<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; am_graph-&gt;num_vertexes; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (am_graph-&gt;arc[i][j] == <span class="number">1</span> &amp;&amp; !visited[j]) &#123;</span><br><span class="line">						visited[j] = <span class="literal">true</span>;</span><br><span class="line">						<span class="built_in">cout</span> &lt;&lt; am_graph-&gt;vexs[j] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">						vertex_queue.push(j);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">邻接表的广度遍历算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverseAL</span><span class="params">(ALGraph&lt;VertexType, EdgeType&gt; *&amp;al_graph)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; vertex_queue;</span><br><span class="line">	EdgeNode&lt;EdgeType&gt; *edge;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; al_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line">		visited_[i] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; al_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!visited_[i]) &#123;</span><br><span class="line">			visited_[i] = <span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; al_graph-&gt;adj_list[i].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			vertex_queue.push(i);  <span class="comment">//顶点index入队列</span></span><br><span class="line">			<span class="keyword">while</span> (!vertex_queue.empty()) &#123;  <span class="comment">//若当前队列不为空</span></span><br><span class="line">				i = vertex_queue.front();  <span class="comment">//返回当前队列首元素</span></span><br><span class="line">				vertex_queue.pop();</span><br><span class="line">				edge = al_graph-&gt;adj_list[i].firstedge;</span><br><span class="line">				<span class="keyword">while</span> (edge) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!visited_[edge-&gt;adjvex]) &#123;  <span class="comment">//若该节点未被访问</span></span><br><span class="line">						visited_[edge-&gt;adjvex] = <span class="literal">true</span>;</span><br><span class="line">						<span class="built_in">cout</span> &lt;&lt; al_graph-&gt;adj_list[edge-&gt;adjvex].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">						vertex_queue.push(edge-&gt;adjvex);</span><br><span class="line">					&#125;</span><br><span class="line">					edge = edge-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图的深度优先遍历与广度优先遍历算法在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同。<strong>深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况。</strong></p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>我们把构造连通网的最小代价生成树称为最小生成树 (Minimum Cost Spanning Tree)。</p>
<h4 id="普里姆-Prim-算法"><a href="#普里姆-Prim-算法" class="headerlink" title="普里姆 (Prim) 算法"></a>普里姆 (Prim) 算法</h4><p>普里姆 (Prim) 算法是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树。<br>构造邻接矩阵：</p>
<p><img src="/posts/ead90048/1578558836503.png" alt="Prim-邻接矩阵"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  最小生成树 Prim 算法的定义</span></span><br><span class="line"><span class="comment">  核心思想：遍历顶点，由顶点找最小权值对应的边</span></span><br><span class="line"><span class="comment">  图示例：9 15 012345678 0 1 10 0 5 11 1 2 18 1 6 16 1 8 12 2 3 22 2 8 8 3 4 20 3 6 24 3 7 16 3 8 21 4 5 26 4 7 7 5 6 17 6 7 19</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;VertexType, EdgeType&gt;::MiniSpanTreePrim(AMGraph&lt;VertexType, EdgeType&gt; *&amp;am_graph) &#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">min</span>, i, j, k;</span><br><span class="line">	<span class="comment">//adjvex保存相关顶点下标；lowcost保存相关顶点间 边的权值</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adjvex, lowcost;</span><br><span class="line">	lowcost.push_back(<span class="number">0</span>);</span><br><span class="line">	adjvex.push_back(<span class="number">0</span>);  <span class="comment">//初始化第一个顶点为v0</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; am_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line">		lowcost.push_back(am_graph-&gt;arc[<span class="number">0</span>][i]);</span><br><span class="line">		adjvex.push_back(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; am_graph-&gt;num_vertexes; i++) &#123;</span><br><span class="line">		<span class="built_in">min</span> = MY_INFINITY;</span><br><span class="line">		j = <span class="number">1</span>; k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &lt; am_graph-&gt;num_vertexes) &#123;  <span class="comment">//遍历结点，查找最小权值 </span></span><br><span class="line">			<span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j] &lt; <span class="built_in">min</span>) &#123;</span><br><span class="line">				<span class="built_in">min</span> = lowcost[j];</span><br><span class="line">				k = j;</span><br><span class="line">			&#125;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; adjvex[k] &lt;&lt; <span class="string">","</span> &lt;&lt; k &lt;&lt; <span class="string">") "</span>;</span><br><span class="line">		lowcost[k] = <span class="number">0</span>;  <span class="comment">//当前顶点的权值置为0</span></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; am_graph-&gt;num_vertexes; j++) &#123;  <span class="comment">//“合并”顶点</span></span><br><span class="line">			<span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; am_graph-&gt;arc[k][j] &lt; lowcost[j]) &#123;</span><br><span class="line">				lowcost[j] = am_graph-&gt;arc[k][j];</span><br><span class="line">				adjvex[j] = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由算法代码中的循环嵌套可得知此算法的时间复杂度为$O(n^2)$。</p>
<h4 id="克鲁斯卡尔-Kruskal-算法"><a href="#克鲁斯卡尔-Kruskal-算法" class="headerlink" title="克鲁斯卡尔 (Kruskal) 算法"></a>克鲁斯卡尔 (Kruskal) 算法</h4><p>克鲁斯卡尔算法将各边按照权值大小排序，由小到大逐步连接顶点来构造最小生成树。<br>以下是 edge 边集数组结构的定义代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KruskalEdge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">begin</span>;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line">	EdgeType weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>将邻接矩阵转换成边集数组，并按照权值大小排序：</p>
<p><img src="/posts/ead90048/1578620201925.png" alt="Kruskal-边集数组"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最小生成树 Kruskal 算法的定义</span></span><br><span class="line"><span class="comment">核心思想：边按照权值排序，由最小权值的边找对应顶点</span></span><br><span class="line"><span class="comment">图示例：9 15 012345678 0 1 10 0 5 11 1 2 18 1 6 16 1 8 12 2 3 22 2 8 8 3 4 20 3 6 24 3 7 16 3 8 21 4 5 26 4 7 7 5 6 17 6 7 19</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;VertexType, EdgeType&gt;::MiniSpanTreeKruskal(AMGraph&lt;VertexType, EdgeType&gt; *&amp;am_graph) &#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i, j, n, m;</span><br><span class="line">	<span class="built_in">vector</span>&lt;KruskalEdge&lt;EdgeType&gt;&gt; edges;  <span class="comment">//边集数组</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent(am_graph-&gt;num_vertexes, <span class="number">0</span>);</span><br><span class="line">	KruskalEdge&lt;EdgeType&gt; kruskal_edge;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; am_graph-&gt;num_vertexes; i++) &#123;  <span class="comment">//边集数组初始化</span></span><br><span class="line">		<span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; am_graph-&gt;num_vertexes; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (am_graph-&gt;arc[i][j] != MY_INFINITY) &#123;</span><br><span class="line">				kruskal_edge.<span class="built_in">begin</span> = i;</span><br><span class="line">				kruskal_edge.<span class="built_in">end</span> = j;</span><br><span class="line">				kruskal_edge.weight = am_graph-&gt;arc[i][j];</span><br><span class="line">				edges.push_back(kruskal_edge);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), CompareWeight);  <span class="comment">//边集数组按照权值由小到大排序</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; am_graph-&gt;num_edges; i++) &#123;</span><br><span class="line">		n = FindIndex(parent, edges[i].<span class="built_in">begin</span>);</span><br><span class="line">		m = FindIndex(parent, edges[i].<span class="built_in">end</span>);</span><br><span class="line">		<span class="keyword">if</span> (n != m) &#123;  <span class="comment">//假如 n 与 m 不等，说明此边没有与现有生成树形成环路</span></span><br><span class="line">			parent[n] = m;  <span class="comment">//将此边的结尾顶点放入下标为起点的 parent 中，表示此頂点已经在生成树集合中</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; edges[i].<span class="built_in">begin</span> &lt;&lt; <span class="string">","</span> &lt;&lt; edges[i].<span class="built_in">end</span> &lt;&lt; <span class="string">") "</span> &lt;&lt; edges[i].weight &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	权值按照由小到大的排序规则</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">CompareWeight</span><span class="params">(<span class="keyword">const</span> KruskalEdge&lt;EdgeType&gt; &amp;first, <span class="keyword">const</span> KruskalEdge&lt;EdgeType&gt; &amp;second)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> first.weight &lt; second.weight;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	查找连线顶点的尾部下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindIndex</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;parent, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (parent[f] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		f = parent[f];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此算法的 FindIndex 函数由边数 edges 决定，时间复杂度为$O(logn)$，而外面有一个 for 循环 e 次。所以克鲁斯卡尔算法的时间复杂度为$O(nlogn)$。<br>对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以对于稀疏图有很大的优势；而普里姆算法对于稠密图，即边数非常多的情况会更好一些。</p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第—个顶点是源点，最后一个顶点是终点。</p>
<h4 id="迪杰斯特拉-Dijkstra-算法"><a href="#迪杰斯特拉-Dijkstra-算法" class="headerlink" title="迪杰斯特拉 (Dijkstra) 算法"></a>迪杰斯特拉 (Dijkstra) 算法</h4><p>这是一个按路径长度递增的次序产生最短路径的算法。该算法一步步求出源点和终点之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到源点到终点的最短路径。<br>示例图如下所示：</p>
<p><img src="/posts/ead90048/1578628039919.png" alt="Dijkstra"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path_matrix_, short_path_table_;  <span class="comment">//存储最短路径下标，到各点最短路径的权值和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最短路径 Dijkstra 算法的定义</span></span><br><span class="line"><span class="comment">核心思想：按路径长度递增的次序迭代（以前一次产生结果为基础）产生最短路径</span></span><br><span class="line"><span class="comment">图示例：9 16 012345678 0 1 1 0 2 5 1 2 3 1 3 7 1 4 5 2 4 1 2 5 7 3 4 2 3 6 3 4 5 3 4 6 6 4 7 9 5 7 5 6 7 2 6 8 7 7 8 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;VertexType, EdgeType&gt;::ShortestPathDijkstra(AMGraph&lt;VertexType, EdgeType&gt; *&amp;am_graph, <span class="keyword">int</span> v0, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path_matrix, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;short_path_table) &#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> v, w, k, <span class="built_in">min</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; final_short_path(am_graph-&gt;num_vertexes, <span class="number">0</span>);  <span class="comment">//final_short_path[w]=1 表示求得顶点v0到vw的最短路径</span></span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; am_graph-&gt;num_vertexes; v++) &#123;  <span class="comment">//数据初始化</span></span><br><span class="line">		path_matrix.push_back(<span class="number">0</span>);</span><br><span class="line">		short_path_table.push_back(am_graph-&gt;arc[v0][v]);</span><br><span class="line">	&#125;</span><br><span class="line">	short_path_table[v0] = <span class="number">0</span>;  <span class="comment">//v0到本身的路径为0</span></span><br><span class="line">	final_short_path[v0] = <span class="number">1</span>;  <span class="comment">//v0到本身不需要求路径</span></span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">1</span>; v &lt; am_graph-&gt;num_vertexes; v++) &#123;</span><br><span class="line">		<span class="built_in">min</span> = MY_INFINITY;</span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; am_graph-&gt;num_vertexes; w++) &#123;  <span class="comment">//查找距离当前顶点最近的顶点k</span></span><br><span class="line">			<span class="keyword">if</span> (final_short_path[w] == <span class="number">0</span> &amp;&amp; short_path_table[w] &lt; <span class="built_in">min</span>) &#123;  <span class="comment">//w顶点离v0顶点更近</span></span><br><span class="line">				k = w;</span><br><span class="line">				<span class="built_in">min</span> = short_path_table[w];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		final_short_path[k] = <span class="number">1</span>;  <span class="comment">//将目前找到的最近的顶点置为1</span></span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; am_graph-&gt;num_vertexes; w++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (final_short_path[w] == <span class="number">0</span> &amp;&amp; (<span class="built_in">min</span> + am_graph-&gt;arc[k][w] &lt; short_path_table[w])) &#123;  <span class="comment">//经过k顶点的路径比现在这条路径短</span></span><br><span class="line">				path_matrix[w] = k;</span><br><span class="line">				short_path_table[w] = <span class="built_in">min</span> + am_graph-&gt;arc[k][w];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迪杰斯特拉 (Dijkstra) 算法解决了从某个源点到其余各顶点的最短路径问题。从循环嵌套可以很容易得到此算法的时间复杂度为$O(n^2)$。<br>如果我们还需要知道如 v3 到 v5，v1 到 v7 这样的任一顶点到其余所有顶点的最短路径怎么办呢？此时简单的办法就是对每个顶点当作源点运行一次迪杰斯特拉 (Dijkstra) 算法，等于在原有算法的基础上，再来一次循环，此时整个算法的时间复杂度就成了$O(n^3)$。</p>
<h4 id="弗洛伊德-Floyd-算法"><a href="#弗洛伊德-Floyd-算法" class="headerlink" title="弗洛伊德 (Floyd) 算法"></a>弗洛伊德 (Floyd) 算法</h4><p>示例如图所示：</p>
<p><img src="/posts/ead90048/1578640691016.png" alt="Floyd"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; floyd_path_matrix_, floyd_short_path_;  <span class="comment">//存储最短路径的中转顶点下标，到各点最短路径的权值和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最短路径 Floyd 算法的定义</span></span><br><span class="line"><span class="comment">核心思想：迭代（以前一次寻找结果为基础）寻找顶点与顶点间的最短中转路径</span></span><br><span class="line"><span class="comment">图示例：9 16 012345678 0 1 1 0 2 5 1 2 3 1 3 7 1 4 5 2 4 1 2 5 7 3 4 2 3 6 3 4 5 3 4 6 6 4 7 9 5 7 5 6 7 2 6 8 7 7 8 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;VertexType, EdgeType&gt;::ShortestPathFloyd(AMGraph&lt;VertexType, EdgeType&gt; *&amp;am_graph, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;floyd_path_matrix, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;floyd_short_path) &#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> v, w, k;</span><br><span class="line">	<span class="comment">// 二维数组初始化</span></span><br><span class="line">	floyd_path_matrix.resize(am_graph-&gt;num_vertexes);</span><br><span class="line">	floyd_short_path.resize(am_graph-&gt;num_vertexes);</span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; am_graph-&gt;num_vertexes; v++) &#123;</span><br><span class="line">		floyd_path_matrix[v].resize(am_graph-&gt;num_vertexes);</span><br><span class="line">		floyd_short_path[v].resize(am_graph-&gt;num_vertexes);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; am_graph-&gt;num_vertexes; v++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; am_graph-&gt;num_vertexes; w++) &#123;</span><br><span class="line">			floyd_short_path[v][w] = am_graph-&gt;arc[v][w];</span><br><span class="line">			floyd_path_matrix[v][w] = w;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//k 代表的是中转顶点的下标。v 代表起始顶点，w代表结束顶点。</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; am_graph-&gt;num_vertexes; k++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; am_graph-&gt;num_vertexes; v++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; am_graph-&gt;num_vertexes; w++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (floyd_short_path[v][w] &gt; floyd_short_path[k][v] + floyd_short_path[k][w]) &#123;  <span class="comment">//通过顶点k中转的路径小于当前路径</span></span><br><span class="line">					floyd_short_path[v][w] = floyd_short_path[k][v] + floyd_short_path[k][w];</span><br><span class="line">					floyd_path_matrix[v][w] = floyd_path_matrix[v][k];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>弗洛伊德 (Floyd) 算法，它的代码简洁到就是一个二重循环初始化加一个三重循环权值修正，就完成了所有顶点到所有顶点的最短路径计算。如此简单的实现，真是巧妙之极。很可惜由于它的三重循<br>环，因此也是$O(n^3)$时间复杂度。如果你面临需要求所有顶点至所有顶点的最短路径问题时，弗洛伊德算法应该是不错的选择。</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为 AOV 网 (Activity On Vertex Network)。<br>设 G=(V,E)是一个具有 n 个顶点的有向图，V 中的顶点序列 v1, v2, ⋯ , vn，满足若从顶点的到 vi 到 vj 有一条路径，则在顶点序列中顶点的必在顶点 vi 之前。则我们称这样的顶点序列为一个拓扑序列。拓扑排序，其实就是对一个有向图构造拓扑序列的过程。<br>对 AOV 网进行拓扑排序的基本思路是：从 AOV 网中选择一个入度为 0 的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者 AOV 网中不存在入度为 0 的顶点为止。考虑到算法过程中始终要查找入度为 0 的顶点，我们在原来顶点表结点结构中，增加一个入度域 in，结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> in;							<span class="comment">//顶点入度</span></span><br><span class="line">	VertexType data;				<span class="comment">//顶点域，存储顶点信息</span></span><br><span class="line">	EdgeNode&lt;EdgeType&gt; *firstedge;	<span class="comment">//边表头栺针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>示例有向图如下：</p>
<p><img src="/posts/ead90048/1578649533784.png" alt="拓扑排序-有向图"></p>
<p><img src="/posts/ead90048/1578649563477.png" alt="拓扑排序-邻接表"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">拓扑排序的定义</span></span><br><span class="line"><span class="comment">函数功能：若网图无回路，输出拓扑排序序列并返回true，若有回路则返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType, <span class="keyword">typename</span> EdgeType&gt;</span><br><span class="line"><span class="keyword">bool</span> Graph&lt;VertexType, EdgeType&gt;::TopologicalSort(ALGraph&lt;VertexType, EdgeType&gt; *&amp;al_graph) &#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i, k, get_top;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">//用于栈指针下标；统计输出顶点的个数</span></span><br><span class="line">	EdgeNode&lt;EdgeType&gt; *edge;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; vertex_stack;  <span class="comment">//存储处理过程中入度为 0 的顶点，目的是为了避免每个查找时都要去遍历顶点表找有没有入度为0的顶点。</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; al_graph-&gt;num_vertexes; i++) &#123;  <span class="comment">//初始化填充入度数字段</span></span><br><span class="line">		<span class="keyword">for</span> (edge = al_graph-&gt;adj_list[i].firstedge; edge; edge = edge-&gt;next) &#123;  <span class="comment">//遍历该顶点对应的边表</span></span><br><span class="line">			al_graph-&gt;adj_list[edge-&gt;adjvex].in++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; al_graph-&gt;num_vertexes; i++) &#123;  <span class="comment">//当前入度为零的顶点入栈</span></span><br><span class="line">		<span class="keyword">if</span> (al_graph-&gt;adj_list[i].in == <span class="number">0</span>) &#123;</span><br><span class="line">			vertex_stack.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!vertex_stack.empty()) &#123;</span><br><span class="line">		get_top = vertex_stack.top();</span><br><span class="line">		vertex_stack.pop();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; al_graph-&gt;adj_list[get_top].data &lt;&lt; <span class="string">" -&gt; "</span>;</span><br><span class="line">		++count;</span><br><span class="line">		<span class="keyword">for</span> (edge = al_graph-&gt;adj_list[get_top].firstedge; edge; edge = edge-&gt;next) &#123;  <span class="comment">//遍历该顶点对应的边表</span></span><br><span class="line">			k = edge-&gt;adjvex;</span><br><span class="line">			<span class="keyword">if</span> (!(--al_graph-&gt;adj_list[k].in)) &#123;  <span class="comment">//当前入度为零的顶点入栈</span></span><br><span class="line">				vertex_stack.push(k);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (count &lt; al_graph-&gt;num_vertexes) &#123;  <span class="comment">//count小于顶点个数，存在环</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对一个具有 n 个顶点 edge 条弧的 AOV 网来说，扫描顶点表，将入度为 0 的顶点入栈的时间复杂为 $O(n)$，而之后的 while 循环中，每个顶点进一次栈，出一次栈，入度减 1 的操作共执行了 edge 次，所以整个算法的时间复杂度为$O(n+edge)$。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>niliqiang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://niliqiang.github.io/posts/ead90048/" title="数据结构--图">https://niliqiang.github.io/posts/ead90048/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
              <a href="/tags/%E5%9B%BE/" rel="tag"># 图</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/d1b5afdd/" rel="prev" title="数据结构--二叉树">
      <i class="fa fa-chevron-left"></i> 数据结构--二叉树
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/9a460acd/" rel="next" title="操作系统--进程与线程">
      操作系统--进程与线程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#图的定义"><span class="nav-number">1.</span> <span class="nav-text">图的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的存储结构"><span class="nav-number">2.</span> <span class="nav-text">图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#邻接矩阵"><span class="nav-number">2.1.</span> <span class="nav-text">邻接矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#邻接表"><span class="nav-number">2.2.</span> <span class="nav-text">邻接表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十字链表"><span class="nav-number">2.3.</span> <span class="nav-text">十字链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#邻接多重表"><span class="nav-number">2.4.</span> <span class="nav-text">邻接多重表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#边集数组"><span class="nav-number">2.5.</span> <span class="nav-text">边集数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的遍历"><span class="nav-number">3.</span> <span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#深度优先遍历"><span class="nav-number">3.1.</span> <span class="nav-text">深度优先遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#广度优先遍历"><span class="nav-number">3.2.</span> <span class="nav-text">广度优先遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最小生成树"><span class="nav-number">4.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#普里姆-Prim-算法"><span class="nav-number">4.1.</span> <span class="nav-text">普里姆 (Prim) 算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#克鲁斯卡尔-Kruskal-算法"><span class="nav-number">4.2.</span> <span class="nav-text">克鲁斯卡尔 (Kruskal) 算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最短路径"><span class="nav-number">5.</span> <span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#迪杰斯特拉-Dijkstra-算法"><span class="nav-number">5.1.</span> <span class="nav-text">迪杰斯特拉 (Dijkstra) 算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#弗洛伊德-Floyd-算法"><span class="nav-number">5.2.</span> <span class="nav-text">弗洛伊德 (Floyd) 算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拓扑排序"><span class="nav-number">6.</span> <span class="nav-text">拓扑排序</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">niliqiang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/niliqiang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;niliqiang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/mailto:ni_liqiang@126.com" title="E-Mail → mailto:ni_liqiang@126.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">niliqiang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
